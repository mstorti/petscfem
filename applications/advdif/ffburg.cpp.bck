/*
  This file belongs to the PETSc - FEM package, a library and
  application suite oriented to the Finite Element Method based on PETSc. 
  Copyright (C) 1999, 2000  Mario Alberto Storti
  
  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  
  You should have received a copy of the GNU General Public License along
  with this program; if not, write to the Free Software Foundation, Inc.,
  59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

*/

#include <stdio.h>
#include <string.h>
#include <vector>
#include <cassert>

#include "../../src/fem.h"
#include "../../src/texthash.h"
#include "../../src/getprop.h"
#include "../../src/utils.h"
#include "../../src/util2.h"
#include "../../src/fastmat2.h"

#include "advective.h"

//---:---<*>---:---<*>---:---<*>---:---<*>---:---<*>---:---<*>---: 
#undef __FUNC__
#define __FUNC__ "flux_fun_advecfm2" 
int flux_fun_burgers(AD_FLUX_FUN_ARGS) {

  int ierr;

  static double diffusivity, tau_fac, flux_law_coefficient;
  static int ndof;

  // Load properties only once.
  FastMat2::branch();
  if (start_chunk) {
    FastMat2::choose(0);
    start_chunk = 0;

    ndof = U.dim(1);
    assert(ndof==1); // Only 1D Burgers considered
    assert(ndim==1);

    //o Diffusivity (viscosity)
    SGETOPTDEF_ND(double,diffusivity,0.);
    //o Flux law is $f= 0.5\,c\. u^2$, where $c$
    // is this coefficient. 
    SGETOPTDEF_ND(double,flux_law_coefficient,1.);
    //o Scale the SUPG upwind term. 
    SGETOPTDEF_ND(double,tau_fac,1.);
  }
  FastMat2::leave();

  ret_options |= SCALAR_TAU;	// tell the advective element routine
				// that we are returning a scalar tau
  double coef = flux_law_coefficient;
  double phi = U.get(1);
  double u = coef*phi;
  double vel = fabs(u);

  A_jac.set(u);
  flux.set(0.5*u*phi);

  if (options & COMP_UPWIND) {

    D_jac.set(diffusivity);
    // grad_U.t(); // This is not neccesary if dims= 1x1
    fluxd.set(grad_U).scale(diffusivity);
    // grad_U.rs(); // This is not neccesary if dims= 1x1

    A_grad_U.rs().prod(A_jac.rs(),grad_U,-1,1,-2,-1,-2);

    lam_max = fabs(u);
    tau_supg.set(0.);
    double h = 2./fabs(iJaco.get(1,1));
    double Uh = 2*vel/h;
    double alpha = diffusivity;
    double tau;

    if (vel > 1e-5*alpha/h) {		// remove singularity when v=0
      double Pe  = vel*h/(2.*alpha);	// Peclet number
      // magic function
      double magic = (fabs(Pe)>1.e-4 ? 1./tanh(Pe)-1./Pe : Pe/3.); 
      tau = tau_fac/Uh*magic; // intrinsic time
    } else {
      tau = tau_fac*h*h/(12.*alpha);
    }
    tau_supg.setel(tau,1,1);
    delta_sc = 0.;
  }
  
  if (options & COMP_SOURCE) {
    G_source.set(0.);		// Only null source term allowed
				// right now!!
  }

}
