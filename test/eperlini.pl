require "$ENV{'PETSCFEM_DIR'}/tools/math.pl";
#print "# PETSCFEM_DIR: $ENV{'PETSCFEM_DIR'}\n";

sub heredoc {
    my $txt = shift();
    my $name = shift();
    $name = "tmp_file_$$.tmp" unless $name;
    open TMP,">$name";
    print TMP $txt;
    close TMP;
    print $name;
}

# usage: makeini(\@STATE,$nnod,$filename,$noise);
sub makeini {
    @U = @{shift()};
    $ndof = $#U;
    $nnod = shift();
    $name = shift();
    $noise = shift();
#    print "name: $name\n";
    if (!$name || !length($name)) {$name =  "tmp_file_$$.tmp";}
    open TMP,">$name";
    @UU = @U;
    for ($k=0; $k<$nnod; $k++) {
	if ($noise) {
	    @UU = @U;
  	    for ($kk=0; $kk<=$#UU; $kk++) {
  		$UU[$kk] *= (1+$noise*2*(rand()-1));
  	    }
	}
	print TMP "@UU\n";
    }
    close TMP;
    print $name;
}

# This is handy for setting options in the .epl data files. 
#
# usage: 
# <: option('OPTION_NAME',DEFAULT_VALUE) :>
# Then creates a line in the output of the form 
#
# OPTION_NAME VALUE
#
# where VALUE can be set through a `-d OPTION_NAME=VALUE' in the
# carl to eperl, or well it is the DEFAULT_VALUE. Pass the
# magic string __NULL__ if you want to pass a null string value. 
sub option {
    $option_name = shift();
    $option_default_val = shift();
    if ($ {$option_name}) {
	$option = $ {$option_name};
	$option="" if $option eq "__NULL__";
    } else {
	$option = $option_default_val;
    }
    print "$option_name $option";
}

#
# Same as before but only prints the value
#	
sub optval {
    $option_name = shift();
    $option_default_val = shift();
    if ($ {$option_name} ) {
	$option = $ {$option_name};
	$option="" if $option eq "__NULL__";
    } else {
	$option = $option_default_val;
    }
    return $option;
}

# usage readm(IDENT,FILE)
sub readm {
    my ($ident,$file)=@_;
    die "Couldn't open file $file\n" unless open MFILE,"$file";
    while (<MFILE>) {
	if (/^\s*$ident\s*=(\S*);/) {
	    close MFILE;
	    return $1;
	}
    }
    close MFILE;
    die "Couldn't find line \"$ident = <value>\"";
    
}

sub import_vals {
    my ($file,$vars)=@_;
    die "Couldn't open file $file\n" unless open MFILE,"$file";
    my $read=1;
    print "# --- START READ FROM \"$file\" ----\n";
    while (<MFILE>) {
	if (/^.__ENDS_READING_VARS__$/) {
	    $read=0;
	    next;
	}
	if (/^.__START_READING_VARS__$/) {
	    $read=1;
	    next;
	}
	next if !$read;
	if (/^\s*(\w*)\s*=(\S*);/) {
	    $vars->{$1} = $2;
	    print "$1 $2\n"
	}
    }
    print "# --- END READ FROM \"$file\" ----\n";
}
    

sub readm_all {
    my @read_var=();
    my ($file)=@_;
    die "Couldn't open file $file\n" unless open MFILE,"$file";
    while (<MFILE>) {
	if (/^\s*(\w*)\s*=(\S*);/) {
	    push @read_var,$1;
	    $ {$1} = $2;
	}
    }
    close MFILE;
    return \@read_var;
}

sub P {
    my $name = shift();
    my $val = shift();
    eval "\${\"$name\"} = $val";
    print "$name $val";
}

sub transcript {
    my $octtmpfile = shift();
    if ($octtmpfile) {
	die "couldn't open $octtmpfile" unless open OCT,">$octtmpfile";
    }
    my $eperlfile = $ENV{'SCRIPT_SRC_PATH'};
    /`/;print <<EOM;
#
# Transcript of ePerl script: $eperlfile
# ===========================
#
EOM
/`/;
    open SCRIPT,$eperlfile;
    my $tr=0;
    while (<SCRIPT>) {
	$tr=0 if /^\#__END_TRANSCRIPT__$/;
	print "#  >$_" if $tr;
	$tr=1 if /^\#__TRANSCRIPT__$/;
    }
    close SCRIPT;

    return if $#_<0;
    /`/; print <<EOM;
#
# Values:
# =======
EOM
/`/;
    foreach $v (@_) {
	print "# \$$v: ${$v}\n";
	print OCT "$v = ${$v};\n" if $octtmpfile;
    }
    close OCT if $octtmpfile;
}

print <<'EOM';
# DON'T EDIT MANUALLY THIS FILE !!!!!!
# This files automatically generated by ePerl from 
# the corresponding `.epl' file. 
EOM
  
1;
