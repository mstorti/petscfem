<:                              # starts ePerl block

#__TRANSCRIPT__
$case="sine";                   # case name
require '../eperlini.pl';       # Initializes ePerl 
@read_var = @{readm_all("$case.data")};# read all variables in octave file
$char_T_conv_i = $u/$Lx;        # conv char. time
$char_T_diff_i = $D/$Lx**2;     # diff char. time
$char_T = 1/max($char_T_diff_i,
                $char_T_conv_i);# char. time
$T = $char_T;                   # period
$Dt = $T/$N_step_period;        # time step
$nstep = $N_step_period * $N_period;
$omega = 2*$PI/$T;              # frequency
$alpha=1.0 unless $alpha;       # can be given from the makefile
if ($per_elem_prop) {
    $nstep=5;
}
$R=1;
$u=0;
#__END_TRANSCRIPT__
transcript("sine.data.res",
    @read_var,
    qw(char_T_conv_i char_T_diff_i
    char_T T Dt nstep omega));  # print variables on output
:>//                            # ends ePerl block

#default definitions
#===========================================================
global_options
ndim 2

chunk_size 4
save_file "save.state"
nsave 20

rtol 1e-2
maxits 100

save_file_pattern "outvector%d.sal"
nsaverot 1000000
nrec  100
nfile 2

nsome 1
save_file_some "sine.some"
print_some_file "sine.some.tmp"

nstep 1
nnwt 1
tol_newton 0
preco_type "lu"
#preco_type "jacobi"

local_time_step 0
consistent_supg_matrix 1
auto_time_step 0

Dt <:=$Dt:>
alpha 1.
#tau_fac 0.

#solve_system 0
#print_linear_system_and_stop

weak_form 0

advective_jacobians_type "global_vector"
advective_jacobians <:=$u:> 0.

diffusive_jacobians_type "<:=$dif_type="full":>"
#if $dif_type eq 'global_scalar'
diffusive_jacobians <:=$D:>
#elsif $dif_type eq 'scalar_per_field'
diffusive_jacobians <:=$D:> <:=$D*2:> <:=$D*3:>
#elsif $dif_type eq 'global_tensor'
diffusive_jacobians <:=$D:> 0 0  <:=$D:>
#elsif $dif_type eq 'per_field_tensor'
diffusive_jacobians <:=$D:> 0 0  <:=$D:> \
                    <:=$D:> 0 0  <:=$D:> \
                    <:=$D:> 0 0  <:=$D:>
#elsif $dif_type eq 'full'
diffusive_jacobians \
                    <:=$D:> 0 0  <:=$D:> \
                    0 0 0 0 \
                    0 0 0 0 \
                    0 0 0 0 \
                    <:=$D:> 0 0  <:=$D:> \
                    0 0 0 0 \
                    0 0 0 0 \
                    0 0 0 0 \
                    <:=$D:> 0 0  <:=$D:>
#else
<:die "not known dif_type: $dif_type\n":>
#endif

#reactive_jacobians_type "<:=$reac_type="full":>"
#reactive_jacobians_type "<:=$reac_type="global_scalar":>"
reactive_jacobians_type "<:=$reac_type="scalar_per_field":>"

#if $reac_type eq 'full'
reactive_jacobians <:=$R:>  0. 0. 0. <:=$R:>  0. 0. 0. <:=$R:>
#reactive_jacobians <:=$R:>  0. 0. 0. <:=3*$R:>  0. 0. 0. <:=10*$R:>
#elsif $reac_type eq 'global_scalar'
reactive_jacobians <:=$R:>
#elsif $reac_type eq 'scalar_per_field'
reactive_jacobians <:=$R:> <:=3*$R:> <:=10*$R:>
#else
<:die "not known reac_type: $reac_type\n":>
#endif

__END_HASH__

#===========================================================
# ndim nu ndof
nodes   2  2  3
__INCLUDE__ <:=$case:>.nod.tmp
__END_NODES__

#===========================================================
elemset newadvdif_advecfm2 4

#Datos del elemento
geometry cartesian2d
npg 4
__END_HASH__
__INCLUDE__ <:=$case:>.con.tmp
__END_ELEMSET__

end_elemsets

#===========================================================
# condicion variable en el tiempo
#
fixa
__INCLUDE__ sine_new.fixa.tmp
__END_FIXA__

# Local Variables: $
# mode: shell-script $
# eval: (setq indent-tabs-mode nil) $
# End: $
