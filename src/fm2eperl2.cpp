// DON'T EDIT MANUALLY THIS FILE !!!!!!
// This files automatically generated by ePerl from 
// the corresponding file (omitting the _eperl) name.


//__INSERT_LICENSE__
//$Id: fm2eperl2.cpp,v 1.2 2002/11/28 15:55:17 mstorti Exp $
#include <math.h>
#include <stdio.h>

#include <src/fem.h>
#include <src/fastmat2.h>
#include <src/fastlib2.h>

//---:---<*>---:---<*>---:---<*>---:---<*>---:---<*>---:---<*>---: 
class eig_cache : public FastMatSubCache {
public:
  const double **A;
  double **W, **V;
  double *A_c,*work,*W_c;
  int lwork;
  eig_cache() { W=V=NULL; A=NULL; A_c=W_c=NULL; work=NULL; }
  ~eig_cache() { 
    delete[] A;
    delete[] W;
    delete[] V;
    delete[] A_c;
    delete[] W_c;
    delete[] work;
  }
};

FastMat2 & FastMat2::eig(const FastMat2 & A) { 
  assert(0); // Not implemented yet
  return *this; 
}

FastMat2 & 
FastMat2::eig(const FastMat2 & A, FastMat2 &V,int compute_eigen_vectors=1) { 
  assert(0); // Not implemented yet
  return *this; 
}

FastMat2 & 
FastMat2::seig(const FastMat2 & A) {
  seig(A,(FastMat2 & )A,0);
  return *this; 
}

extern "C" void dsyev_(const char*jobz,const char *uplo,int *n,double *a,int *lda,
		       double *w,double *work, int *lwork, int *info);



//---:---<*>---:---<*>---:---<*>---:---<*>---:---<*>---:---<*>---: 
FastMat2 &
FastMat2::seig(const FastMat2 & A, FastMat2 &V,int compute_eigen_vectors=1) { 

  FastMatCache *cache;

if (was_cached) {
  cache = cache_list_begin[position_in_cache++];
#ifdef FM2_CACHE_DBG
  printf ("reusing cache: ");
#endif
} else if (!use_cache) {
  cache = new FastMatCache;
} else {
  cache = new FastMatCache;
  cache_list->push_back(cache);
  cache_list_begin = cache_list->begin();
  cache_list->list_size =
    cache_list_size = cache_list->size();
  position_in_cache++;
#ifdef FM2_CACHE_DBG
  printf ("defining cache: ");
#endif
}
#ifdef FM2_CACHE_DBG
printf(" cache_list %p, cache %p, position_in_cache %d\n",
       cache_list,cache,position_in_cache-1);
#endif
;

  eig_cache *ecache;
  int &cev = compute_eigen_vectors;
  if (!was_cached) {
    Indx Adims;
    A.get_dims(Adims);
    int ndims = Adims.size();
    assert (ndims==2);
    assert (Adims[0] == Adims[1]);
    int m= Adims[0];

    Indx Wdims,Wdims_c, Vdims;
    Wdims_c.push_back(m);
    if (!defined) {
      create_from_indx(Wdims_c);
    }
      
    get_dims(Wdims);
    assert(Wdims == Wdims_c);
    
    if (cev) {
      if (!V.defined) V.create_from_indx(Adims);
      V.get_dims(Vdims);
      assert(Adims == Vdims);
    }

    ecache = new eig_cache();
    assert(ecache);
    assert(!cache->sc);
    cache->sc = ecache;

    ecache->A = new (const double *)[m*m];
    ecache->W = new (double *)[m];
    if (cev) ecache->V = new (double *)[m*m];
    ecache->A_c = new double[m*m];
    ecache->W_c = new double[m];
    ecache->lwork = 5*m;
    ecache->work = new double[ecache->lwork];

    int jj=0;
    Indx Aindx(2,0),Windx(1,0);
    for (int j=1; j<=m; j++) {
      Windx[0] = j;
      ecache->W[j-1] = location(Windx);
      for (int k=1; k<=m; k++) {
	Aindx[0]=j;
	Aindx[1]=k;
	ecache->A[jj] = A.location(Aindx);
	if (cev) ecache->V[jj] = V.location(Aindx);
	jj++;
      }
    }
  }

  ecache  = dynamic_cast<eig_cache *> (cache->sc);
  int m = this->dims_p[0].dim;
  const double **pfrom = ecache->A;

  int m2=m*m;
  for (int j=0; j<m2; j++) ecache->A_c[j] = *(ecache->A[j]);
  int info;
  dsyev_((cev ? "V" : "N"),
	 "U",&m,ecache->A_c,&m,ecache->W_c,
	 ecache->work,&ecache->lwork,&info);

  for (int j=0; j<m; j++) *(ecache->W[j]) = ecache->W_c[j];
  if (cev) for (int j=0; j<m2; j++) *(ecache->V[j]) = ecache->A_c[j];

  if (!use_cache) delete cache;
  return *this;
#undef A
#undef iA
}

// DON'T EDIT MANUALLY THIS FILE !!!!!!
// This files automatically generated by ePerl from 
// the corresponding file (omitting the _eperl) name.

