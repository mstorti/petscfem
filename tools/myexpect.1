.\" Automatically generated by Pod::Man v1.34, Pod::Parser v1.13
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "MYEXPECT 1"
.TH MYEXPECT 1 "2003-11-16" "perl v5.8.0" "User Contributed Perl Documentation"
.SH "NAME"
myexpext.pl: verifies output from program tests
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\f(CW\*(C`expect(FILE,MESSAGE,patlist)\*(C'\fR verifies that each pattern in
\&\f(CW\*(C`patlist\*(C'\fR matches lines in \s-1FILE\s0.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The simplest way of using \f(CW\*(C`expect()\*(C'\fR is to write a list of patterns
that should be found in the output of the test. Suppose the output
contains:
.PP
.Vb 8
\&  Output run of program QBFG running on day Sun Apr  8 08:48:23 ART 2001
\&  ..... more lines here
\&  Total volume: 34.56
\&  more lines here...
\&  Total area: 23.43
\&  more lines here...
\&  Total impedance: 46.4
\&  more lines here...
.Ve
.PP
You want to check that figures in lines \f(CW\*(C`Total...\*(C'\fR are precise
to the first digit. The ouput is in file \f(CW\*(C`QBFG.out\*(C'\fR and you write a
small perl program like this
.PP
.Vb 1
\&   #!/usr/bin/perl
.Ve
.PP
.Vb 1
\&   require 'myexpect.pl';
.Ve
.PP
.Vb 5
\&   expect("QBFG.out","Check on ouput of QBFG.out",<<'EOT');
\&   Total volume: 34.5
\&   Total area: 23.4
\&   Total impedance: 4
\&   EOT
.Ve
.PP
.Vb 1
\&   final_check();
.Ve
.PP
In the default mode, \f(CW\*(C`expect()\*(C'\fR takes the first pattern at a time
and starts scanning the file from the beginning, each lie at a time
until it finds a line that matches the pattern. Patterns are the usual
Perl patterns. So that remember to escape asterisks '\f(CW\*(C`*\*(C'\fR', question
marks '\f(CW\*(C`?\*(C'\fR', dots and others. You can leave the dot unescaped since
it matches itself, but the pattern is less strict (dot matches any
other character also).  Normally, when entering patterns with a \fIhere
in\fR document, as in the previous example, you protect the backslash
characters in the pattern list using quotes in the \f(CW'EOT'\fR
terminator.
.PP
If the pattern is not found an error is reported and the test is
counted as a failure. If a line matching is found, \f(CW\*(C`expect()\*(C'\fR takes
the folowing pattern and continue scanning the file from the line
following the previous match. If all the patterns are matched, then
the test is counted as a succes. If \f(CW\*(C`FILE\*(C'\fR can't be opened, then this
is reported separately from error. The final count is reported by a
call to \f(CW\*(C`final_check()\*(C'\fR.
.Sh "Special directives"
.IX Subsection "Special directives"
You can alter this default behavior adding \fIspecial directives\fR in
the pattern list. They are
.ie n .IP """_\|_REWIND_\|_""" 4
.el .IP "\f(CW_\|_REWIND_\|_\fR" 4
.IX Item "__REWIND__"
Rewind the file, i.e. scan for the next match starting from the
beginning of the file, rather than from the last match. This is useful
when you don't know exactly the order in which the lines will appear.
For instance file
.Sp
.Vb 5
\&   #------ contents of file test1.out
\&   line at the beginning
\&   ...
\&   other line 
\&   ...
.Ve
.Sp
matches the following call
.Sp
.Vb 5
\&   expect("test1.out","Check on ouput of test1.out",<<'EOT');
\&   other line 
\&   __REWIND__
\&   line at the beginning
\&   EOT
.Ve
.Sp
thanks to the presence of the _\|_REWIND_\|_ directive. 
.ie n .IP """_\|_BACKWARD_\|_""" 4
.el .IP "\f(CW_\|_BACKWARD_\|_\fR" 4
.IX Item "__BACKWARD__"
Scan the file backward for the next and subsequent patterns.
.ie n .IP """_\|_FORWARD_\|_""" 4
.el .IP "\f(CW_\|_FORWARD_\|_\fR" 4
.IX Item "__FORWARD__"
Cancel the _\|_BACKWARD_\|_ directive and continue scanning forward. 
.ie n .IP """_\|_NO_SKIP_\|_""" 4
.el .IP "\f(CW_\|_NO_SKIP_\|_\fR" 4
.IX Item "__NO_SKIP__"
In no-skip mode the following pattern line is checked to match with
exactly the following output line, rather to scan the whole output
file from the following line down.
.ie n .IP """_\|_SKIP_\|_""" 4
.el .IP "\f(CW_\|_SKIP_\|_\fR" 4
.IX Item "__SKIP__"
Return to skip mode. 
.ie n .IP """_\|_EXACT_MATCH_\|_""" 4
.el .IP "\f(CW_\|_EXACT_MATCH_\|_\fR" 4
.IX Item "__EXACT_MATCH__"
Pattern has to match exactly the beginning of the line. (No special 
meaning for characters like \f(CW\*(C`.\*(C'\fR, \f(CW\*(C`*\*(C'\fR, etc...
.ie n .IP """_\|_REGEXP_MATCH_\|_""" 4
.el .IP "\f(CW_\|_REGEXP_MATCH_\|_\fR" 4
.IX Item "__REGEXP_MATCH__"
Go back to regexp match. 
.ie n .IP """_\|_SWITCH_FILE_\|_ <file"">" 4
.el .IP "\f(CW_\|_SWITCH_FILE_\|_ <file\fR>" 4
.IX Item "__SWITCH_FILE__ <file>"
Stop reading this output file and switch over to \f(CW\*(C`file\*(C'\fR. File 
name is taken absolute if starts with \f(CW\*(C`/\*(C'\fR otherwise relative to the 
current working directory. The working directory is taken from the
first file entered or changed with the \f(CW\*(C`_\|_CONFIG_ WD "<dir>"\*(C'\fR 
(directive. Example:
.Sp
.Vb 1
\&   __SWITCH_FILE__ foodir/foofile.out
.Ve
.ie n .IP """_\|_CONFIG_\|_""" 4
.el .IP "\f(CW_\|_CONFIG_\|_\fR" 4
.IX Item "__CONFIG__"
Allows changing configuration variables. Syntax is
.Sp
.Vb 1
\&      __CONFIG__  var "value" ...
.Ve
.Sp
Set configuration variable \f(CW$var\fR to \f(CW\*(C`value\*(C'\fR. Current configuration
variables are
.RS 4
.ie n .IP """PRE""\fR, \f(CW""SEP""\fR, \f(CW""POST""" 8
.el .IP "\f(CWPRE\fR, \f(CWSEP\fR, \f(CWPOST\fR" 8
.IX Item "PRE, SEP, POST"
The patterns that matches for the start, end and separator 
of an embedded block. (See below)
.ie n .IP """COMMENT""" 8
.el .IP "\f(CWCOMMENT\fR" 8
.IX Item "COMMENT"
The pattern that, when at the start of a line means a
comment. Default: \f(CW\*(C`#>>\*(C'\fR.
.ie n .IP """WD""" 8
.el .IP "\f(CWWD\fR" 8
.IX Item "WD"
The working directory.
.RE
.RS 4
.Sp
The double quote delimiter around \f(CW\*(C`value\*(C'\fR may be changed by any
non-blank character. Examples:
.Sp
.Vb 2
\&   __CONFIG__ PRE "<<" SEP "><" POST ">>" WD "foodir/bardir" COMMENT "#"
\&   __CONFIG__ PRE COMMENT |#:|
.Ve
.Sp
The last one sets comment start to \f(CW\*(C`#:\*(C'\fR. 
.RE
.Sh "Embedded blocks"
.IX Subsection "Embedded blocks"
You can embed Perl code blocks in the pattern for checking the result
of the matches themselves. The syntax is \f(CW\*(C`{{CONDITION}}\*(C'\fR or
\&\f(CW\*(C`{{PATTERN}{CONDITION}}\*(C'\fR. In the first form the \f(CW\*(C`{{...}}\*(C'\fR block is
replaced with \f(CW\*(C`(.*)\*(C'\fR. If the output line matches, then every
\&\f(CW\*(C`CONDITION\*(C'\fR is evaluated and the line matches if every condition
returns true. Inside the condition the special variable \f(CW$W\fR takes 
the value of the matching string. Example: the following output lines
.PP
.Vb 2
\&  Total mass: 0.356, 
\&    max density: 0.48956, min density: 0.001234
.Ve
.PP
match the following pattern lines
.PP
.Vb 2
\&  Total mass: {{abs($W-0.355)<2e-3}}, 
\&    max density: {{abs($W-0.4)<0.1}}, min density: {{$W<2e-3}}
.Ve
.PP
In the second form the \f(CW\*(C`PATTERN\*(C'\fR section allows to specify pattern 
which is replaces the block. Example: the output line
.PP
.Vb 1
\&  Total items: 890.
.Ve
.PP
matches
.PP
.Vb 1
\&  Total items: {{\ed*}{$W<1000}}\e.
.Ve
.PP
The syntax of the block may be changed with the \f(CW\*(C`_\|_CONFIG_\|_\*(C'\fR
directive. The corresponding variables are \f(CW\*(C`PRE\*(C'\fR, \f(CW\*(C`SEP\*(C'\fR y 
<\s-1POST\s0>. Possible choices are 
.PP
.Vb 9
\&  #>> Following three examples use matching delimiters (like <>, () or[])
\&  #>> warning: angles (<>) may collide with comparison expressions
\&  __CONFIG__ PRE "((" SEP ")(" POST "))"
\&  __CONFIG__ PRE "<<" SEP "><" POST ">>"
\&  __CONFIG__ PRE "[[" SEP "][" POST "]]"
\&  #>> This is very simple
\&  __CONFIG__ PRE "{" SEP "," POST "}"
\&  #>> Another simple one
\&  __CONFIG__ PRE "<" SEP "|" POST "}"
.Ve
.PP
In order to avoid collision you can increase the delimiter levels, e.g.
.PP
.Vb 4
\&  #>> Very paranoid
\&  __CONFIG__ PRE "{{{{" SEP "}}{{" POST "}}}}"
\&  #>> Combines with colon
\&  __CONFIG__ PRE "<<:" SEP ":><:" POST ":>>"
.Ve
.Sh "Sections"
.IX Subsection "Sections"
Sometimes it is useful to divide tests into sections. Start sections
with \f(CW\*(C`begin_section("section name")\*(C'\fR, and end with \f(CW\*(C`end_section()\*(C'\fR.
All enclosed calls to \f(CW\*(C`expect()\*(C'\fR are assumed to be in the same
logical section of tests and a summary is reported for that section.
Example:
.PP
.Vb 5
\& begin_section("Navier stokes tests");
\& expect("NS/output1.txt","NS Test 1","NS Test 1 OK");
\& expect("NS/output1.txt","NS Test 2","NS Test 2 OK");
\& expect("NS/output1.txt","NS Test 3","NS Test 3 OK");
\& end_section();
.Ve
.PP
.Vb 6
\& begin_section("Electro-magnetic tests");
\& expect("EM/output1.txt","EM Test 1","EM Test 1 OK");
\& expect("EM/output1.txt","EM Test 2","EM Test 2 OK");
\& expect("EM/output1.txt","EM Test 3","EM Test 3 OK");
\& expect("EM/output1.txt","EM Test 4","EM Test 4 OK");
\& end_section();
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Mario A. Storti <mstorti@intec.unl.edu.ar>
