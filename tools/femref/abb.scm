(use-modules (ice-9 receive))

(define (t s) (format #t "trace ~A\n" s))

(define (abb-insert1 q x)
  (cond ((null? q) (values 1 (list x '() '())))
	(else (let ((root (car q))
		    (left (cadr q))
		    (right (caddr q)))
		(cond ((< x root) 
		       (receive (ins abb-new) (abb-insert1 left x)
				(values ins (list root  abb-new right))))
		      ((> x root) 
		       (receive (ins abb-new) (abb-insert1 right x)
				(values ins (list root left abb-new))))
		      (else (values 0 q)))))))

(define (abb-insert abb1 . elems)
  (let loop ((inserted 0)
	     (abb abb1)
	     (q elems))
    (cond ((null? q) (values inserted abb))
	  (else 
	   (receive (ins1 abb-new) (abb-insert1 abb (car q))
;		    (format #t "inserting ~A, inserted ~A\n"
;			    abb-new ins1)
		    (loop (+ ins1 inserted) abb-new (cdr q)))))))

(define (abb-print abb1)
  (let loop ((abb abb1))
    (cond ((null? abb) (format #t " ."))
	  (else (let ((root (car abb))
		      (left (cadr abb))
		      (right (caddr abb)))
		  (cond ((and (null? left) (null? right)) (format #t " ~A" root))
			(else (format #t " (~A" root)
			      (loop left)
			      (loop right)
			      (format #t " )")))))))
  (newline))

(define (abb-size abb)
  (cond ((null? abb) 0)
	(else (+ 1 (abb-size (cadr abb)) (abb-size (caddr abb))))))

(define (rand-list n m)
  (let loop ((q '())
	     (j 0))
    (cond ((= j n) q)
	  (else (loop (cons (random m) q) (+ j 1))))))

;; returns bool min max
(define (abb?-aux a)
  (cond ((null? a) (values #t #f #f))
	(else (let ((root (car a))
		    (left (cadr a))
		    (right (caddr a)))
		(receive (isl minl maxl) (abb?-aux left)
;			 (format #t "left ~A, isl ~A, minl ~A, maxl ~A\n"
;				 left isl minl maxl)
			 (cond ((not isl) (values #f #f #f))
			       ((and maxl (> maxl root)) 
;				(format #t "maxl ~A, root ~A\n" maxl root)
				(values #f #f #f))
			       (else 
				(receive (isr minr maxr) (abb?-aux right)
;					 (format #t "right ~A, isr ~A, minr ~A, maxr ~A\n"
;						 right isr minr maxr)
					 (cond ((not isr) (values #f #f #f))
					       ((and minr (< minr root)) (values #f #f #f))
					       (else 
;						(format #t "abb ~A, returns ~A ~A ~A\n" 
;							a #t minl maxr)
						(values #t 
							(cond (minl minl)
							      (else root))
							(cond (maxr maxr)
							      (else root)))))))))))))

(define (abb? a)
  (cond ((null? a) #t)
	(else (let ((root (car a))
		    (left (cadr a))
		    (right (caddr a)))
		(cond ((and (not (null? left)) (< (car left) root)) 
		       #f)
		      ((and (not (null? right)) (< (car right) root)) #f)
		      (else #t))))))

(define (abb-rand m n)
  (let ((l (rand-list m n)))
    (receive (ins abb) (apply abb-insert '() l)
	     abb)))

(define (abb-erase-min abb)
  (cond ((null? abb) #t)
	(else (let ((root (car abb))
		    (left (cadr abb))
		    (right (caddr abb)))
		(cond ((null? left) (values root right))
		      (else (receive (min new-left) (abb-erase-min left)
				     (values min (list root new-left right)))))))))

(define (abb-erase abb x)
  (cond ((null? abb) (values abb #f))
	(else (let ((root (car abb))
		    (left (cadr abb))
		    (right (caddr abb)))
		(cond ((= x root) (values (abb-erase-root-aux left right) 1))
		      ((> x root) 
		       (receive (new-right erased) (abb-erase right x)
				(values (list root left new-right) erased)))
		      (else
;		       (format #t "left ~A erased ~A\n" left erased)
		       (receive (new-left erased) (abb-erase left x)
				(values (list root new-left right) erased))))))))

(define (abb-erase-root-aux left right)
  (cond ((null? left) right)
	((null? right) left)
	(else
	 (receive (min-right new-right) (abb-erase-min right)
		  (list min-right left new-right)))))

; (define (abb-erase-root abb)
;   (let ((root (car abb))
; 	(left (cadr abb))
; 	(right (caddr abb)))
;     (receive (min new-left) (erase-min abb)

(define (tryme m n) 
  (let ((l (rand-list m n)))
    (format #t "inserting ~A\n" l)
    (receive (ins abb) (apply abb-insert '() l)
	     (format #t "inserted ~A elements\n" ins)
	     (abb-print abb)))
  abb)

(define (tryme2 m n) 
  (let ((abb (abb-rand m n)))
    (abb-print abb)
    (format #t "size ~A\n" (abb-size abb))))

(define (tryme3 n)
  (let ((abb (abb-rand n n)))
    (let loop ((q abb))
      (cond ((not (null? q))
	     (format #t "q ~A" q)
	     (receive (min qq) (abb-erase-min q)
		      (format #t ", min ~A\n" min)
		      (loop qq)))))))

(define (tryme4 n)
  (let ((abb (abb-rand n n)))
    (let loop ((q abb)
	       (j 0))
      (cond ((not (= j n))
	     (format #t "erase j ~A from q " j) (abb-print q)
	     (receive (qq erased) (abb-erase q j)
		      (loop qq (+ j 1))))))))
  

(define (tryme5 n)
  (let loop ((abb '()))
    (format #t "abb") (abb-print abb)
    (let ((x1 (random n))
	  (x2 (random n)))
      (receive (ins new-abb) (abb-insert abb x1)
	       (format #t "inserted ~A, " x1) (abb-print new-abb)
	       (receive (new-abb2 er) (abb-erase new-abb x2)
			(format #t "erased ~A, " x2)(abb-print new-abb2)
			(format #t "-----------------\n")
			(loop new-abb2))))))
