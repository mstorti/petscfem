(use-modules (ice-9 format))

(define (compose p1 p2)
  (let* ((n1 (vector-length p1))
	 (n2 (vector-length p2))
	 (q (make-vector n1))
	 (j 0))
    (if (not (= n1 n2)) (error "p1 and p2 should have equal length!\n"))
    (while (< j n1)
	   (let ((indx (vector-ref p1 j)))
	     (vector-set! q j (vector-ref p2 indx)))
	   (set! j (+ 1 j)))
    q))

(define (perm-id n)
  (let ((q (make-vector n))
	(j 0))
    (while (< j n)
	   ((vector-set! q j j))
	   (set! j (+ 1 j)))))

(define (prod q G)
  (let loop ((g G)
	     (qG '()))
    (cond ((null? g) (append qG G))
	  (else (let ((qg (compose q (car g))))
		  (if (member qg G) 
		      (loop (cdr g) qG)
		      (loop (cdr g) (cons qg qG))))))))


;; (format #t "~A" (compose (vector 1 2 0) (vector 1 2 0)))

(define g (vector 1 2 3 4 5 0))
(define G (list g))
(let ((n 10)
      (j 0))
  (while (< j n)
	 (format #t "~A\n" G)
	 (set! G (prod g G))
	 (set! j (+ 1 j))))
