(use-modules (ice-9 format))

(define (compose p1 p2)
  (let* ((n1 (vector-length p1))
	 (n2 (vector-length p2))
	 (q (make-vector n1))
	 (j 0))
    (if (not (= n1 n2)) (error "p1 and p2 should have equal length!\n"))
    (while (< j n1)
	   (let ((indx (vector-ref p1 j)))
	     (vector-set! q j (vector-ref p2 indx)))
	   (set! j (+ 1 j)))
    q))

(define (perm-id n)
  (let ((q (make-vector n))
	(j 0))
    (while (< j n)
	   ((vector-set! q j j))
	   (set! j (+ 1 j)))))

(define (prod-aux q G side)
  (format #t "hi\n")
  (let loop ((g G)
	     (qG '()))
    (format #t "qG: ~A\n" qG)
    (cond ((null? g) qG)
	  (else (let ((pair-prod (cond ((eq? side 'left (compose q (car g))))
				       (else (compose (car g) q)))))
		  (format #t "pair-prod: ~A\n" pair-prod)
		  (format #t "G: ~A\n" G)
		  (format #t "(member pair-prod G) : ~A\n" (member pair-prod G))
		  (if (member pair-prod G) 
		      (loop (cdr g) qG)
		      (begin
			(display "branching\n")
			(format #t "qG inner: ~A\n" qG)
			(format #t "(cons pair-prod qG): ~A\n" (cons pair-prod qG))
			(loop (cdr g) (cons pair-prod qG)))))))))

(define (prod arg1 arg2)
  (cond ((list? arg2) (prod-aux arg1 arg2 'left))
	(else (prod-aux arg2 arg1 'right))))

;(define (generate q G)
;  (let loop ((GG 

;; (format #t "~A" (compose (vector 1 2 0) (vector 1 2 0)))

(define g (vector 1 2 3 4 5 0))
(define G (list g))
; (let ((n 10)
;       (j 0))
;   (while (< j n)
; 	 (format #t "~A\n" G)
; 	 (set! G (prod g G))
; 	 (set! j (+ 1 j))))

(define (lex-compare a b)
  (let ((na (vector-length a))
	(nb (vector-length b)))
    (if (not (= na nb)) (error "a and b should have same lenght\n"))
    (let loop ((j 0))
      (cond ((= j na) #f)
	    (else (let ((wa (vector-ref a j))
			(wb (vector-ref b j)))
		    (cond ((= wa wb) (loop (+ 1 j)))
			  (else (< wa wb)))))))))

(define (prod g G)
  (let ((gGg (append G 
		     (map (lambda (x) (compose g x)) G) 
		     (map (lambda (x) (compose x g)) G))))
    (sort gGg lex-compare)))

;(format #t "(prod g G): ~A\n" (prod g G))

(let ((a (vector 0 1 2 3 4))
      (b (vector 0 1 1 3 4)))
  (format #t "a: ~A, b: ~A, a<b: ~A\n" a b (lex-compare a b)))
