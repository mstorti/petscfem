%__INSERT_LICENSE__

\Section{The general advective-diffusive elemset} 

\SSection{Introduction to advective systems of equations} 

Advective system of equations are of the form
%
\begin{equation} 
 \dep{!H(!U)_\mu}t + \dep{}{x_i}\F^\conv_{i\mu}(!U) +
             \dep{}{x_i}\F^\diff_{i\mu}(!U,\nabla !U) = G_\mu(!U)
\end{equation}
%
and its numerical treatment is similar to the advective elemset.  The
$!H(!U)$ is a one to one relationship between tha \emph{``state
variables''} $!U$ and the \emph{``conservation variables''}
$!H$. $\F^{\diff,\conv}$ are the convective and diffusive fluxes
respectively. We use the SUPG variational formulation
%
\begin{equation} 
\begin{split}
 \int_\Omega N_p (\dep{!H_\mu}t & - G_\mu
        +\cswf \, \dep{}{x_i}\F^\conv_{i\mu} ) \di\Omega + \\
   &   -\int_\Omega  \dep{N_p}{x_i} \, (\swf \F^\conv_{i\mu} 
        + \F^\diff_{i\mu})  \di\Omega  \\
     & + \int_\Gamma (\swf \F^\conv_{i\mu} 
        + \F^\diff_{i\mu}) n_i \di\Gamma \\
     & + \sum_e \int_{\Omega_e} 
     \taufac \, !P_{ep} \, \LL\{\bsupg \dep{!H_\mu}t + 
        \dep{}{x_i}\F_{i\mu}
              - G_\mu \RR\} \di\Omega =0
\end{split}
\end{equation}
%
where
%
\begin{itemize}
\item $N_p$ is the interpolation function for the $p$-th node. 
\item The variational formulation represents an equation for each node
$p$ and equation $\mu$. 
\index{weak_form@\verb+weak_form+}
\item $\swf$ is the \emph{``weak form selector''} (option
\verb+weak_form+).  It may take the values $0,1$ and $!\swf = 1-\swf$
is its complement. It controls the integration by parts (or not) of
the advective term.
\index{beta_supg@\verb+beta_supg+}
\item $0\le\bsupg\le 1$ (option \verb+beta_supg+) controls whether the
temporal term is treated consistently or not.
\item $P_{ep}(!x)$ is the SUPG \emph{``perturbation function''} for node
$p$ on element $e$. For systems, as it is here, it may be a matrix of
size $\ndof\times\ndof$. 
\item The integral on the boundary is computed in elemsets of type
\verb+bcconv+, whereas the rest are computed in elemset of type
\verb+advdif+. 
\end{itemize}

\SSection{Flux jacobians}

The \emph{``flux jacobians''} are the derivatives of the fluxes to the
different components:

\begin{itemize}
\item The \emph{``advective jacobians''} are
%
\begin{equation}
A_{i\mu\nu} = \dep{}{U_\nu} {\F^\conv_{i\mu}}
\end{equation}
%
The projection of the jacobian on a given direction $!n$ is 
%
\[
  (!A\cdot!n)_{\mu\nu} = A_{i\mu\nu} n_i
\]
%
By the theory of advective systems of equations it is assumed that the
projection of the jacobians on any direction $!n$ must be a
diagonalizable matrix with real eigenvalues.

\item The \emph{``diffusive jacobians''} are 
%
\begin{equation}
D_{ij\mu\nu} = -\dep{}{(\prt_j U_\nu)} {\F^\diff_{i\mu}}
\end{equation}
%
It is assumed that the diffusive jacobians are symmetric possitive definite if
seen as a square matrix of row/column dimension of \(\ndim\ndof\). 

\item The \emph{``reactive jacobians''} are
%
\[ R_{\mu\nu} = -\dep{U_\nu}{G_\mu} \]
%
Normally, it is assumed that the eigenvalues have positive real part,
otherwise an exponential grow may happen. 

\item The \emph{``enthalpy jacobians''} or \emph{``capacitance
matrix''} is
%
\[   C_{\mu\nu} = \dep{U_\nu}{H_\mu}  \]

\end{itemize}

\SSection{The flux function class} 

The particular relations for each physical problem are passed through
a \emph{``flux function''} (class \verb+AdvDifFF+) object whose
abstract interface is the following

\begin{verbatim}
class EnthalpyFun {
public:
  virtual void update(const double *) {};
  virtual void enthalpy(FastMat2 &H, FastMat2 &U)=0;
  virtual void comp_W_Cp_N(FastMat2 &W_Cp_N,FastMat2 &W,FastMat2 &N,
			   double w)=0;
  virtual void comp_P_Cp(FastMat2 &P_Cp,FastMat2 &P_supg)=0;
};

class AdvDifFF {
private:
  // ...
public:
  const Elemset *elemset;
  EnthalpyFun *enthalpy_fun;
  AdvDifFF(Elemset *elemset_=NULL) 
    : elemset(elemset_), enthalpy_fun(NULL) {};
  virtual void start_chunk(int &ret_options) =0;
  virtual void element_hook(ElementIterator &element) =0;
  virtual void comp_A_grad_N(FastMat2 & A,FastMat2 & B)=0;
  virtual void comp_A_jac_n(FastMat2 &A_jac_n, FastMat2 &normal)=0;
  virtual void comp_grad_N_D_grad_N(FastMat2 &grad_N_D_grad_N,
				    FastMat2 & dshapex,double w) =0 ;
  virtual void compute_flux(COMPUTE_FLUX_ARGS) =0;
  virtual void get_log_vars(int &nlog_vars,const int *& log_vars);
  virtual void comp_N_N_C(FastMat2 &N_N_C,FastMat2 &N,double w)=0;
  virtual void comp_N_P_C(FastMat2 &N_P_C, FastMat2 &P_supg,
			  FastMat2 &N,double w)=0;
};
\end{verbatim}

\index{matrix shells}
\SSection{Matrix Shells} 

The class contains a number of members that define the different
fluxes and jacobians. Instead of returning explicitly the full
jacobian, the interface allows to only define the action of the
jacobian on other matrices. This is termed a \emph{``matrix shell''}
(a similar concept exists in PETSc).  This may improve efficiency when
the jacobians are sparse or null. For instance the function
\verb+comp_A_grad_N(FastMat2 & A_grad_N,FastMat2 & grad_N)+ should
return the product (\verb+A_grad_N+)$_{p\mu\nu}$ = $A_{i\mu\nu}\,
\deps{N_p}{x_i}$ of size $\nel\times\ndof\times\ndof$ on output when
passed a matrix (\verb+grad_N+)$_{ip} = \deps{N_p}{x_i}$ of size
$\ndim\times\nel$. The details of the dimension in each matrix shell
may vary, accordingly to the evolution of the elemset. Please consult
the \manpages. In some cases the matrix shell may define more complex
products involving more than one input matrices and a scalar factor. 

\index{Enthalpy function objectcs}
\SSection{Enthalpy function objectcs}

The enthalpy/temperature relationship is passed through a so called
\emph{``enthalpy function object''}, whose virtual class interface is
shown above. The flux function contains a pointer to an enthalpy
object. The methods in the enthalpy function class are
\verb+void update(double *)+ which is passed an array of doubles in
order to update the values the define the function, and to matrix
shells that define the capacitance matrix or enthalpy jacobian defined
above. 

%<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*> 
\SSSection{Options}

\begin{description}
%<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*> 
\item[General options:] ~

\begin{itemize}
\input odocadvdif
\end{itemize}

%<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*> 
\item[Generic elemset ``{\tt advdife}'':] ~

\begin{itemize}
\input odocadvdife
\end{itemize}

%<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*> 
\item[Flux function``{\tt advec}'':] Generic linear
advective-diffusive system

All fluxes and \(G_\mu\) are linear in \(!U\) and its gradients. 

\begin{equation}
\begin{split}
  \F^\conv_{i\mu} &= A_{j\mu\nu} U_\nu \\
  \F^{\diff}_{i\mu} &= -\D_{ij\mu\nu}\, \prt_j U^\nu\\
   G_\mu &= -R_{\mu\nu} U_\nu + S_\nu
\end{split}
\end{equation}

\begin{itemize}
\input odocadvfm2
\end{itemize}

\textbf{Programming notes:}

In order to define the operator you have to define the coefficients in
$!A$, $!D$, $!C$, $!R$ and $!S$. Much as in the case for the general
flux function, these operators are defined as matrix shells. The
corresponding classes are

\begin{verbatim}
class SourceTerm {
public:
  virtual void add_source_term(FastMat2 &G_source)=0;
};

class CJac {
public:
  virtual void comp_N_N_C(FastMat2 &N_N_C,FastMat2 &N,double w)=0;
  virtual void comp_G_source(FastMat2 &G_source, FastMat2 &U)=0;
  virtual void comp_N_P_C(FastMat2 &N_P_C, FastMat2 &P_supg,
			  FastMat2 &N,double w)=0;
};

class AJac {
public:
  virtual void comp_A_grad_N(FastMat2 & A,FastMat2 & B)=0;
  virtual void comp_A_grad_U(FastMat2 & A,FastMat2 & B)=0;
  virtual void comp_A_jac_n(FastMat2 &A_jac_n, FastMat2 &normal)=0;
  virtual void comp_Uintri(FastMat2 & A,FastMat2 & B)=0;
  virtual void comp_flux(FastMat2 & A,FastMat2 & B) =0 ;
  virtual void comp_vel_per_field(FastMat2 &vel_per_field)=0;
};

class DJac {
public:
  virtual void comp_grad_N_D_grad_N(FastMat2 &grad_N_D_grad_N,
				    FastMat2 & dshapex,double w) =0 ;
  virtual void comp_fluxd(FastMat2 & A,FastMat2 & B) =0 ;
  virtual void comp_dif_per_field(FastMat2 &dif_per_field)=0;
  virtual void update(const double *difjac)=0;
};
\end{verbatim}

A number of derived classes are provided. For instance class
\verb+AJac+ is derived in classes \verb+NullAJac+, \verb+UGlobal+,
\verb+UPerField+ and \verb+FullAdvJac+. the \verb+NullAJac+ class
means a null advection term and then when making products with the
advective jacobian matrices the result is set directly to null. Of
course you could define them as \verb+FullAdvJac+ and then set all
coefficients to 0, but in that case all computations should be
performed, which is much less efficient. 

If you consider to develop another jacobian class, then you have to
instantiate the corresponding virtual functions (matrix shells). 

%<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*> 
\item[Flux function``{\tt burgers}'':] Burgers eqs.

\begin{itemize}
\input odocburgers
\end{itemize}

\SSection{Logarithmic variables} 

In many problems some quantities are intrinsically positive (pressure,
density) but, do to numerical inaccuracies (mainly numerical spurious
oscillations) they can acquire null or negative variables. This in
turn can cause a breakdown of the general algorithm, since this
quantities may appear in the denominator of some expressions, or as
the argument of functions which only accept positive values (as the 
\verb+log()+ \verb+sqrt()+ functions. 

A very typical case is the $k-\epsilon$ turbulence model, where both
quantities are intrinsically positive but vary strongly near walls,
and is very common to reach negative values and cause the breakdown of
the code. 

One common source of oscillations is the use of very small time steps
in a diffusive equation (as the heat equation) with consistent mass
matrix. The problem disappears if a lumped mas matrix is used. Another
source is a lack of stabilization of advective terms. The problem is
solved by using a better stabilization scheme or increasing the amount
of stabilization. 

Even with a careful stabilization scheme and time integration, 
it is very common to have code breakdown and so there is interest in
develop numerical schemes that, due to some special tratment of time
or spatial discretization guarantee positivity. 

One possibility is to map the variable space with a logarithmic
transformation. For instance, if we have an ODE of the form
%
\begin{equation} 
   \dot u = f(u,t)
\end{equation}
%
If this equation is discretized with the trapezoidal rule integration
method
%
\begin{equation} 
  \frac{u^{n+1}-u^n}{\Dt} = f(u^{n+\alpha},t^{n+\alpha})
\end{equation}
%
where $t^n=n\Dt$, $t^{n+\alpha}=t^n+\alpha\Dt$, $0\le\alpha\le1$, then
it may happen that $u$ gets negative values, even if $u$ is guaranteed
to be strictly positive in the continuous case. Now consider the
change of variable
%
\begin{equation} 
  u = \ze^\cU
\end{equation}
%
then, the transformed equation is
%
\begin{equation} 
   u \, \dot\cU = f(u,t)
\end{equation}
%
and the trapezoidal discretization is
%
\begin{equation} 
   u^{n+\alpha} \, \frac{\cU^{n+1}-\cU^{n}}{\Dt} = 
             f(u^{n+\alpha},t^{n+\alpha})
\end{equation}



\end{description}


%
% Local Variables: *
% mode: latex *
% tex-main-file: "petscfem.tex" *
% End: *
