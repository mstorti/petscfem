%__INSERT_LICENSE__

\Section{The general advective-diffusive elemset} 

\SSection{Introduction to advective systems of equations} 

Advective system of equations are of the form
%
\begin{equation} 
 \dep{!H(!U)_\mu}t + \dep{}{x_i}\F^\conv_{i\mu}(!U) +
             \dep{}{x_i}\F^\diff_{i\mu}(!U,\nabla !U) = G_\mu(!U)
\end{equation}
%
and its numerical treatment is similar to the advective elemset.  The
$!H(!U)$ is a one to one relationship between tha \emph{``state
variables''} $!U$ and the \emph{``conservation variables''}
$!H$. $\F^{\diff,\conv}$ are the convective and diffusive fluxes
respectively. We use the SUPG variational formulation
%
\begin{equation} 
\begin{split}
 \int_\Omega N_p (\dep{!H_\mu}t & - G_\mu
        +\cswf \, \dep{}{x_i}\F^\conv_{i\mu} ) \di\Omega + \\
   &   -\int_\Omega  \dep{N_p}{x_i} \, (\swf \F^\conv_{i\mu} 
        + \F^\diff_{i\mu})  \di\Omega  \\
     & + \int_\Gamma (\swf \F^\conv_{i\mu} 
        + \F^\diff_{i\mu}) n_i \di\Gamma \\
     & + \sum_e \int_{\Omega_e} 
     \taufac \, !P_{ep} \, \LL\{\bsupg \dep{!H_\mu}t + 
        \dep{}{x_i}\F_{i\mu}
              - G_\mu \RR\} \di\Omega =0
\end{split}
\end{equation}
%
where
%
\begin{itemize}
\item $N_p$ is the interpolation function for the $p$-th node. 
\item The variational formulation represents an equation for each node
$p$ and equation $\mu$. 
\index{weak_form@\verb+weak_form+}
\item $\swf$ is the \emph{``weak form selector''} (option
\verb+weak_form+).  It may take the values $0,1$ and $!\swf = 1-\swf$
is its complement. It controls the integration by parts (or not) of
the advective term.
\index{beta_supg@\verb+beta_supg+}
\item $0\le\bsupg\le 1$ (option \verb+beta_supg+) controls whether the
temporal term is treated consistently or not.
\item $P_{ep}(!x)$ is the SUPG \emph{``perturbation function''} for node
$p$ on element $e$. For systems, as it is here, it may be a matrix of
size $\ndof\times\ndof$. 
\item The integral on the boundary is computed in elemsets of type
\verb+bcconv+, whereas the rest are computed in elemset of type
\verb+advdif+. 
\end{itemize}

\SSection{Flux jacobians}

The \emph{``flux jacobians''} are the derivatives of the fluxes to the
different components:

\begin{itemize}
\item The \emph{``advective jacobians''} are
%
\begin{equation}
A_{i\mu\nu} = \dep{}{U_\nu} {\F^\conv_{i\mu}}
\end{equation}
%
The projection of the jacobian on a given direction $!n$ is 
%
\[
  (!A\cdot!n)_{\mu\nu} = A_{i\mu\nu} n_i
\]
%
By the theory of advective systems of equations it is assumed that the
projection of the jacobians on any direction $!n$ must be a
diagonalizable matrix with real eigenvalues.

\item The \emph{``diffusive jacobians''} are 
%
\begin{equation}
D_{ij\mu\nu} = -\dep{}{(\prt_j U_\nu)} {\F^\diff_{i\mu}}
\end{equation}
%
It is assumed that the diffusive jacobians are symmetric possitive definite if
seen as a square matrix of row/column dimension of \(\ndim\ndof\). 

\item The \emph{``reactive jacobians''} are
%
\[ R_{\mu\nu} = -\dep{U_\nu}{G_\mu} \]
%
Normally, it is assumed that the eigenvalues have positive real part,
otherwise an exponential grow may happen. 

\item The \emph{``enthalpy jacobians''} or \emph{``capacitance
matrix''} is
%
\[   C_{\mu\nu} = \dep{U_\nu}{H_\mu}  \]

\end{itemize}

\SSection{The flux function class} 

The particular relations for each physical problem are passed through
a \emph{``flux function''} (class \verb+AdvDifFF+) object whose
abstract interface is the following

\begin{verbatim}
class EnthalpyFun {
public:
  virtual void update(const double *) {};
  virtual void enthalpy(FastMat2 &H, FastMat2 &U)=0;
  virtual void comp_W_Cp_N(FastMat2 &W_Cp_N,FastMat2 &W,FastMat2 &N,
			   double w)=0;
  virtual void comp_P_Cp(FastMat2 &P_Cp,FastMat2 &P_supg)=0;
};

class AdvDifFF {
private:
  // ...
public:
  const Elemset *elemset;
  EnthalpyFun *enthalpy_fun;
  AdvDifFF(Elemset *elemset_=NULL) 
    : elemset(elemset_), enthalpy_fun(NULL) {};
  virtual void start_chunk(int &ret_options) =0;
  virtual void element_hook(ElementIterator &element) =0;
  virtual void comp_A_grad_N(FastMat2 & A,FastMat2 & B)=0;
  virtual void comp_A_jac_n(FastMat2 &A_jac_n, FastMat2 &normal)=0;
  virtual void comp_grad_N_D_grad_N(FastMat2 &grad_N_D_grad_N,
				    FastMat2 & dshapex,double w) =0 ;
  virtual void compute_flux(COMPUTE_FLUX_ARGS) =0;
  virtual void get_log_vars(int &nlog_vars,const int *& log_vars);
  virtual void comp_N_N_C(FastMat2 &N_N_C,FastMat2 &N,double w)=0;
  virtual void comp_N_P_C(FastMat2 &N_P_C, FastMat2 &P_supg,
			  FastMat2 &N,double w)=0;
};
\end{verbatim}

\index{matrix shells}
\SSection{Matrix Shells} 

The class contains a number of members that define the different
fluxes and jacobians. Instead of returning explicitly the full
jacobian, the interface allows to only define the action of the
jacobian on other matrices. This is termed a \emph{``matrix shell''}
(a similar concept exists in PETSc).  This may improve efficiency when
the jacobians are sparse or null. For instance the function
\verb+comp_A_grad_N(FastMat2 & A_grad_N,FastMat2 & grad_N)+ should
return the product (\verb+A_grad_N+)$_{p\mu\nu}$ = $A_{i\mu\nu}\,
\deps{N_p}{x_i}$ of size $\nel\times\ndof\times\ndof$ on output when
passed a matrix (\verb+grad_N+)$_{ip} = \deps{N_p}{x_i}$ of size
$\ndim\times\nel$. The details of the dimension in each matrix shell
may vary, accordingly to the evolution of the elemset. Please consult
the \manpages. In some cases the matrix shell may define more complex
products involving more than one input matrices and a scalar factor. 

\index{Enthalpy function objectcs}
\SSection{Enthalpy function objectcs}

The enthalpy/temperature relationship is passed through a so called
\emph{``enthalpy function object''}, whose virtual class interface is
shown above. The flux function contains a pointer to an enthalpy
object. The methods in the enthalpy function class are
\verb+void update(double *)+ which is passed an array of doubles in
order to update the values the define the function, and to matrix
shells that define the capacitance matrix or enthalpy jacobian defined
above. 

%<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*> 
\SSSection{Options}

\begin{description}
%<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*> 
\item[General options:] ~

\begin{itemize}
\input odocadvdif
\end{itemize}

%<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*> 
\item[Generic elemset ``{\tt advdife}'':] ~

\begin{itemize}
\input odocadvdife
\end{itemize}

%<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*> 
\item[Flux function``{\tt advec}'':] Generic linear
advective-diffusive system

All fluxes and \(G_\mu\) are linear in \(!U\) and its gradients. 

\begin{equation}
\begin{split}
  \F^\conv_{i\mu} &= A_{j\mu\nu} U_\nu \\
  \F^{\diff}_{i\mu} &= -\D_{ij\mu\nu}\, \prt_j U^\nu\\
   G_\mu &= -R_{\mu\nu} U_\nu + S_\nu
\end{split}
\end{equation}

\begin{itemize}
\input odocadvfm2
\end{itemize}

\textbf{Programming notes:}

In order to define the operator you have to define the coefficients in
$!A$, $!D$, $!C$, $!R$ and $!S$. Much as in the case for the general
flux function, these operators are defined as matrix shells. The
corresponding classes are

\begin{verbatim}
class SourceTerm {
public:
  virtual void add_source_term(FastMat2 &G_source)=0;
};

class CJac {
public:
  virtual void comp_N_N_C(FastMat2 &N_N_C,FastMat2 &N,double w)=0;
  virtual void comp_G_source(FastMat2 &G_source, FastMat2 &U)=0;
  virtual void comp_N_P_C(FastMat2 &N_P_C, FastMat2 &P_supg,
			  FastMat2 &N,double w)=0;
};

class AJac {
public:
  virtual void comp_A_grad_N(FastMat2 & A,FastMat2 & B)=0;
  virtual void comp_A_grad_U(FastMat2 & A,FastMat2 & B)=0;
  virtual void comp_A_jac_n(FastMat2 &A_jac_n, FastMat2 &normal)=0;
  virtual void comp_Uintri(FastMat2 & A,FastMat2 & B)=0;
  virtual void comp_flux(FastMat2 & A,FastMat2 & B) =0 ;
  virtual void comp_vel_per_field(FastMat2 &vel_per_field)=0;
};

class DJac {
public:
  virtual void comp_grad_N_D_grad_N(FastMat2 &grad_N_D_grad_N,
				    FastMat2 & dshapex,double w) =0 ;
  virtual void comp_fluxd(FastMat2 & A,FastMat2 & B) =0 ;
  virtual void comp_dif_per_field(FastMat2 &dif_per_field)=0;
  virtual void update(const double *difjac)=0;
};
\end{verbatim}

A number of derived classes are provided. For instance class
\verb+AJac+ is derived in classes \verb+NullAJac+, \verb+UGlobal+,
\verb+UPerField+ and \verb+FullAdvJac+. the \verb+NullAJac+ class
means a null advection term and then when making products with the
advective jacobian matrices the result is set directly to null. Of
course you could define them as \verb+FullAdvJac+ and then set all
coefficients to 0, but in that case all computations should be
performed, which is much less efficient. 

If you consider to develop another jacobian class, then you have to
instantiate the corresponding virtual functions (matrix shells). 

%<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*> 
\item[Flux function``{\tt burgers}'':] Burgers eqs.

\begin{itemize}
\input odocburgers
\end{itemize}

\SSection{Logarithmic variables} 

In many problems some quantities are intrinsically positive (pressure,
density) but, do to numerical inaccuracies (mainly numerical spurious
oscillations) they can acquire null or negative variables. This in
turn can cause a breakdown of the general algorithm, since this
quantities may appear in the denominator of some expressions, or as
the argument of functions which only accept positive values (as the 
\verb+log()+ \verb+sqrt()+ functions. 

A very typical case is the $k-\epsilon$ turbulence model, where both
quantities are intrinsically positive but vary strongly near walls,
and is very common to reach negative values and cause the breakdown of
the code. 

One common source of oscillations is the use of very small time steps
in a diffusive equation (as the heat equation) with consistent mass
matrix. The problem disappears if a lumped mas matrix is used. Another
source is a lack of stabilization of advective terms. The problem is
solved by using a better stabilization scheme or increasing the amount
of stabilization. 

Even with a careful stabilization scheme and time integration, 
it is very common to have code breakdown and so there is interest in
develop numerical schemes that, due to some special tratment of time
or spatial discretization guarantee positivity. 

One possibility is to map the variable space with a logarithmic
transformation. For instance, if we have an ODE of the form
%
\begin{equation} 
   \dot u = f(u,t)
\end{equation}
%
If this equation is discretized with the trapezoidal rule integration
method
%
\begin{equation} 
  \frac{u^{n+1}-u^n}{\Dt} = f(u^{n+\alpha},t^{n+\alpha})
\end{equation}
%
where $t^n=n\Dt$, $t^{n+\alpha}=t^n+\alpha\Dt$, $0\le\alpha\le1$, then
it may happen that $u$ gets negative values, even if $u$ is guaranteed
to be strictly positive in the continuous case. Now consider the
change of variable
%
\begin{equation} 
  u = \ze^\cU
\end{equation}
%
then, the transformed equation is
%
\begin{equation} 
   u \, \dot\cU = f(u,t)
\end{equation}
%
and the trapezoidal discretization is
%
\begin{equation} 
   u^{n+\alpha} \, \frac{\cU^{n+1}-\cU^{n}}{\Dt} = 
             f(u^{n+\alpha},t^{n+\alpha})
\end{equation}

\index{load element}
\index{film element}
\SSection{Generic surface load element/film coefficient}

%<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*> 
\begin{figure*}[htb]
\centerline{\includegraphics{./OBJ/genloadsl.\EPSPDF}}
\caption{Constant surface heat load on a surface}
\label{fg:genloadsl}
\end{figure*}
%<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*> 

%<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*> 
\begin{figure*}[htb]
\centerline{\includegraphics{./OBJ/genloaddl.\EPSPDF}}
\caption{$\Delta T$ driven surface heat load on a surface}
\label{fg:genloaddl}
\end{figure*}
%<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*> 

This element allows the user to apply generic loads to surfaces
volumes, lines of nodes or even individual nodes. Taking for instance
the heat equation, consider boundary conditions of the form
%
\begin{equation} \label{eq:hfilm}  
  k\dep Tn = q'' = \begin{cases}
                        q''_0;&\text{constant flux}\\
                        h\, (T_\infty - T_s);&\text{$\Delta T$ driven flux}
                   \end{cases}
\end{equation}
%
Where $q''_0$ is a heat flow applied to the surface, independently of
its temperature and the second term represents the exchange of heat to
an external fluid of temperature $T_\infty$ to the surface of the body
at temperature $T_s$. $h>0$ is the \emph{``film coefficient''}.  The
generic elemset that represents generic non-linear loads of the form
$!q(!U_\infty,!U_s)$ where $!U$ is the generic state of the fluid and
$!q$ the generic flux is the \verb+GenLoad+ class. Specific classes
can be derived by defining the specific flux function. The simplest is
the \verb+lin_gen_load+ class that represents constant or linear relation, as in
(\ref{eq:hfilm}), or a combination of both of them. 

If there is no temperature dependent exchange, i.e. if $h=0$ then you
simply enter the nodes on the surface element and the heat source as
the \verb+hfilm_source+ property. You should enter as many real values
as fields there are in the problem, they represent the constant load
to be applied to the respective field.  Note that in that case the amount
of heat entered is constant per element. This element can be entered
as constant for the elemset or entered per-element. The quantity
entered must be a density of heat flux, i.e. a flux heat per unit
length or unit surface depending if in 2D or 3D. For instance 
%
\begin{verbatim}
elemset lin_gen_load 2
geometry cartesian1d
npg 2
hfilm_source -3. -1.
__END_HASH__
35 36
__END_ELEMSET__
\end{verbatim}
%
means an elemset with only one surface element with constant heat load
but not film coefficient load. The loads are $-3 \rm W/m$ for the first field
and $-1 \rm W/m$ for the second. 

In the $\Delta T$ driven case you must specify the $T_\infty$
temperature by including fictitious nodes, for instance
%
\begin{verbatim}
elemset lin_gen_load 4
geometry cartesian1d
double_layer
npg 2
hfilm_coeff 3. 0. 0. 1.
__END_HASH__
35 36 120 121
__END_ELEMSET__
\end{verbatim}
%
Represents a film between a surface and an external medium (see
figure~\ref{fg:genloaddl}), nodes 35 and 36 are on the surface while
120 and 121 in the external medium. There are two fields and the
applied flux is
%
\begin{equation}
\begin{split}
   k \dep{U_1} n &= q''_1 = 3 \, (U_\infty-U_1)\\
   k \dep{U_2} n &= q''_2 = 1 \, (U_\infty-U_1)
\end{split}
\end{equation}
%
The option \verb+double_layer+ has to be set for this case. In general
you can have almost any kind of surface element (linear in 2D,
triangle or quadrangle in 3D, see figure~\ref{fg:genlother}). In
general you enter the connectivities of the surface element on the
body (first layer) and then the corresponding nodes in the fluid
(second layer). For instance 
%
\index{lin_gen_load elemset@\verb+lin_gen_load+ elemset}
\begin{verbatim}
elemset lin_gen_load 6
geometry cartesian2d
double_layer
npg 2
hfilm_coeff 3. 0. 0. 1.
__END_HASH__
n1 n2 n3 n4 n5 n6
__END_ELEMSET__
\end{verbatim}
%
for triangles or
%
\begin{verbatim}
elemset lin_gen_load 6
geometry cartesian2d
double_layer
npg 2
hfilm_coeff 3. 0. 0. 1.
__END_HASH__
n1 n2 n3 n4 n5 n6 n7 n8
__END_ELEMSET__
\end{verbatim}
%
for quadrangles in 3D. 

In general the state of the external medium ($T_\infty$) is specified
so that the degrees of freedom of the corresponding nodes should be
fixed. It may be also the reverse case (first layer fixed and second
layer free) or both layers free. This last case may serve, for
instance, to represent a thermal resistance caused by a thin layer of
a very insulating material, where we can neglect the lateral gradients
of temperature. 

%<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*> 
\begin{figure*}[htb]
\centerline{\includegraphics{./OBJ/genlother.\EPSPDF}}
\caption{$\Delta T$ driven surface heat load on a surface}
\label{fg:genlother}
\end{figure*}
%<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*> 

\SSSection{Related Options}

\begin{itemize}
\input odocgenl
\end{itemize}

\end{description}


%
% Local Variables: *
% mode: latex *
% tex-main-file: "petscfem.tex" *
% End: *
