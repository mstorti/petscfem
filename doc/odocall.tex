%-----<>-----<>-----<>-----<>-----<>-----<>-----<>-----<>-----<>-----<>
% DON'T EDIT MANUALLY THIS FILE !!!!!!
% This files automatically generated by odoc.pl from 
% source file ""
%-----<>-----<>-----<>-----<>-----<>-----<>-----<>-----<>-----<>-----<>
\index{A@\verb+A+}
\item\verb+double A+ {\rm(default=\verb|peak-base|)}:

The height (with reference to the base) of the Gaussian
 (found in file: \verb+../src/tempfun2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{A@\verb+A+}
\item\verb+double A+ {\rm(default=\verb|1.|)}:

amplitud of impulse
 (found in file: \verb+../src/tempfun2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{A0@\verb+A0+}
\item\verb+double A0+ {\rm(default=\verb|-0.217|)}:

Parameter of the model
 (found in file: \verb+../applications/advdif/wallswt.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{A1@\verb+A1+}
\item\verb+double A1+ {\rm(default=\verb|5.50|)}:

Parameter of the model
 (found in file: \verb+../applications/advdif/wallswt.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{A2@\verb+A2+}
\item\verb+double A2+ {\rm(default=\verb|2.50|)}:

Parameter of the model
 (found in file: \verb+../applications/advdif/wallswt.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{A3@\verb+A3+}
\item\verb+double A3+ {\rm(default=\verb|8.5|)}:

Parameter of the model
 (found in file: \verb+../applications/advdif/wallswt.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{A\_0@\verb+A_0+}
\item\verb+double A_0+ {\rm(default=\verb|0.|)}:

Shift in the amplitud value linear transformation.
$A = A_0 + A_scale * \alpha$, where $A$ is the amplitude to
apply to the diplacements and $\alpha$ are the values entered
in the file. 
 (found in file: \verb+../src/tempfun2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{A\_scale@\verb+A_scale+}
\item\verb+double A_scale+ {\rm(default=\verb|1.|)}:

Temporal scale in the time linear transformation.
 (found in file: \verb+../src/tempfun2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{A\_van\_Driest@\verb+A_van_Driest+}
\item\verb+int A_van_Driest+ {\rm(default=\verb|0|)}:

If {\tt A\_van\_Driest=0} then the van Driest
   damping factor is not used 
 (found in file: \verb+../applications/ns/ns.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{A\_van\_Driest@\verb+A_van_Driest+}
\item\verb+double A_van_Driest+ {\rm(default=\verb|0|)}:

van Driest constant for the damping law.
 (found in file: \verb+../applications/ns/nsilesther.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{A\_van\_Driest@\verb+A_van_Driest+}
\item\verb+double A_van_Driest+ {\rm(default=\verb|0|)}:

van Driest constant for the damping law.
 (found in file: \verb+../applications/ns/nsitetlesfm2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{CN\_ctff@\verb+CN_ctff+}
\item\verb+double CN_ctff+ {\rm(default=\verb|0.0|)}:

Cutoff value for CN
 (found in file: \verb+../applications/advdif/gaschem.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{CO\_ctff@\verb+CO_ctff+}
\item\verb+double CO_ctff+ {\rm(default=\verb|0.0|)}:

Cutoff value for CO
 (found in file: \verb+../applications/advdif/gaschem.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{C\_1@\verb+C_1+}
\item\verb+double C_1+ {\rm(default=\verb|1.44|)}:

C_1
 (found in file: \verb+../applications/advdif/bubbly.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{C\_1@\verb+C_1+}
\item\verb+double C_1+ {\rm(default=\verb|1.44|)}:

Coefficient for shallow water turbulent model
 (found in file: \verb+../applications/advdif/ffswfm1t.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{C\_1@\verb+C_1+}
\item\verb+double C_1+ {\rm(default=\verb|1.44|)}:

Coefficient for shallow water turbulent model
 (found in file: \verb+../applications/advdif/ffswfm2t.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{C\_1@\verb+C_1+}
\item\verb+double C_1+ {\rm(default=\verb|1.44|)}:

C_1
 (found in file: \verb+../applications/ns/nsikeps.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{C\_1@\verb+C_1+}
\item\verb+double C_1+ {\rm(default=\verb|1.44|)}:

C_1
 (found in file: \verb+../applications/ns/nsikepsrot.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{C\_2@\verb+C_2+}
\item\verb+double C_2+ {\rm(default=\verb|1.92|)}:

C_2
 (found in file: \verb+../applications/advdif/bubbly.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{C\_2@\verb+C_2+}
\item\verb+double C_2+ {\rm(default=\verb|1.92|)}:

Coefficient for shallow water turbulent model
 (found in file: \verb+../applications/advdif/ffswfm1t.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{C\_2@\verb+C_2+}
\item\verb+double C_2+ {\rm(default=\verb|1.92|)}:

Coefficient for shallow water turbulent model
 (found in file: \verb+../applications/advdif/ffswfm2t.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{C\_2@\verb+C_2+}
\item\verb+double C_2+ {\rm(default=\verb|1.92|)}:

C_2
 (found in file: \verb+../applications/ns/nsikeps.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{C\_2@\verb+C_2+}
\item\verb+double C_2+ {\rm(default=\verb|1.92|)}:

C_2
 (found in file: \verb+../applications/ns/nsikepsrot.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{C\_mu@\verb+C_mu+}
\item\verb+double C_mu+ {\rm(default=\verb|0.09|)}:

C_mu
 (found in file: \verb+../applications/advdif/bubbly.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{C\_mu@\verb+C_mu+}
\item\verb+double C_mu+ {\rm(default=\verb|0.09|)}:

Coefficient for shallow water turbulent model
 (found in file: \verb+../applications/advdif/ffswfm1t.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{C\_mu@\verb+C_mu+}
\item\verb+double C_mu+ {\rm(default=\verb|0.09|)}:

Coefficient for shallow water turbulent model
 (found in file: \verb+../applications/advdif/ffswfm2t.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{C\_mu@\verb+C_mu+}
\item\verb+double C_mu+ {\rm(default=\verb|0.09|)}:

C_mu (turbulence constant)
 (found in file: \verb+../applications/ns/nonlr.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{C\_mu@\verb+C_mu+}
\item\verb+double C_mu+ {\rm(default=\verb|0.09|)}:

C_mu
 (found in file: \verb+../applications/ns/nsikeps.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{C\_mu@\verb+C_mu+}
\item\verb+double C_mu+ {\rm(default=\verb|0.09|)}:

C_mu
 (found in file: \verb+../applications/ns/nsikepsrot.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{C\_smag@\verb+C_smag+}
\item\verb+double C_smag+ {\rm(default=\verb|0.09|)}:

C_smag
 (found in file: \verb+../applications/advdif/gasflow.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{C\_smag@\verb+C_smag+}
\item\verb+double C_smag+ {\rm(default=\verb|0.18|)}:

Smagorinsky constant.
 (found in file: \verb+../applications/ns/nsilesther.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{C\_smag@\verb+C_smag+}
\item\verb+double C_smag+ {\rm(default=\verb|0.18|)}:

Smagorinsky constant.
 (found in file: \verb+../applications/ns/nsitetlesfm2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{CdN\_ctff@\verb+CdN_ctff+}
\item\verb+double CdN_ctff+ {\rm(default=\verb|0.0|)}:

Cutoff value for CdN
 (found in file: \verb+../applications/advdif/gaschem.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{CdO\_ctff@\verb+CdO_ctff+}
\item\verb+double CdO_ctff+ {\rm(default=\verb|0.0|)}:

Cutoff value for CdO
 (found in file: \verb+../applications/advdif/gaschem.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{Chezy@\verb+Chezy+}
\item\verb+double Chezy+ {\rm(default=\verb|110|)}:

Chezy coefficient for bottom friction modelling
 (found in file: \verb+../applications/advdif/ffswfm1t.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{Chezy@\verb+Chezy+}
\item\verb+double Chezy+ {\rm(default=\verb|110|)}:

Chezy coefficient for bottom friction modelling
 (found in file: \verb+../applications/advdif/ffswfm2t.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{Courant@\verb+Courant+}
\item\verb+double Courant+ {\rm(default=\verb|0.6|)}:

The Courant number.
 (found in file: \verb+../applications/advdif/advdif.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{Courant@\verb+Courant+}
\item\verb+double Courant+ {\rm(default=\verb|0.6|)}:

The Courant number.
 (found in file: \verb+../applications/advdif/advdif_bubbly.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{Courant@\verb+Courant+}
\item\verb+double Courant+ {\rm(default=\verb|0.6|)}:

The Courant number.
 (found in file: \verb+../applications/advective/adv.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{Cp@\verb+Cp+}
\item\verb+double Cp+ {\rm(default=\verb|1.|)}:

Specific heat - constant pressure
 (found in file: \verb+../applications/ns/bccnstherfm2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{Cp@\verb+Cp+}
\item\verb+double Cp+ {\rm(default=\verb|1.|)}:

Specific heat - constant pressure
 (found in file: \verb+../applications/ns/nsilesther.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{Cr@\verb+Cr+}
\item\verb+double Cr+ {\rm(default=\verb|0.|)}:

Coefficient scaling the reaction 
 (found in file: \verb+../applications/advdif/smoke.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{D@\verb+D+}
\item\verb+double D+ {\rm(default=\verb|1.|)}:

Coefficient for shallow water turbulent model
 (found in file: \verb+../applications/advdif/ffswfm1t.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{D@\verb+D+}
\item\verb+double D+ {\rm(default=\verb|1.|)}:

Coefficient for shallow water turbulent model
 (found in file: \verb+../applications/advdif/ffswfm2t.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{Dt@\verb+Dt+}
\item\verb+double Dt+ {\rm(default=\verb|0.|)}:

Time step. 
 (found in file: \verb+../applications/advdif/advdif.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{Dt@\verb+Dt+}
\item\verb+double Dt+ {\rm(default=\verb|0.|)}:

Time step. 
 (found in file: \verb+../applications/advdif/advdif_bubbly.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{Dt@\verb+Dt+}
\item\verb+double Dt+ {\rm(default=\verb|0.|)}:

Time step. 
 (found in file: \verb+../applications/advective/adv.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{Dt@\verb+Dt+}
\item\verb+double Dt+ {\rm(default=\verb|0.|)}:

The time step.
 (found in file: \verb+../applications/ns/ns.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{Dt@\verb+Dt+}
\item\verb+double Dt+ {\rm(default=\verb|0.|)}:

Time step
 (found in file: \verb+../applications/ns/qharmm.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{Dt@\verb+Dt+}
\item\verb+double Dt+ {\rm(default=\verb|0.|)}:

Time step
 (found in file: \verb+../test/spillway/alehook.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{Dt@\verb+Dt+}
\item\verb+double Dt+ {\rm(default=\verb|0.|)}:

Time step.
 (found in file: \verb+../test/spillway/alehook.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\item\verb+ double[ndim]+ \verb+ G_body+ {\rm(default=\verb| <null-vector>|)}:
 Vector of gravity acceleration (must be constant).  (found in file: \verb+../applications/advdif/bubbly.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\item\verb+ double[ndim]+ \verb+ G_body+ {\rm(default=\verb| null vector|)}:
 Vector of gravity acceleration (must be constant).  (found in file: \verb+../applications/advdif/gasflow.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\item\verb+ double[ndim]+ \verb+ G_body+ {\rm(default=\verb| null vector|)}:
 Vector of gravity acceleration (must be constant).  (found in file: \verb+../applications/ns/nsikeps.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\item\verb+ double[ndim]+ \verb+ G_body+ {\rm(default=\verb| null vector|)}:
 Vector of gravity acceleration (must be constant).  (found in file: \verb+../applications/ns/nsikepsrot.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\item\verb+ double[ndim]+ \verb+ G_body+ {\rm(default=\verb| null vector|)}:
 Vector of gravity acceleration (must be constant).  (found in file: \verb+../applications/ns/nsilesther.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\item\verb+ double[ndim]+ \verb+ G_body+ {\rm(default=\verb| null vector|)}:
 Vector of gravity acceleration (must be constant).  (found in file: \verb+../applications/ns/nsirot.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\item\verb+ double[ndim]+ \verb+ G_body+ {\rm(default=\verb| null vector|)}:
 Vector of gravity acceleration (must be constant).  (found in file: \verb+../applications/ns/nsitetlesfm2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{KN@\verb+KN+}
\item\verb+double KN+ {\rm(default=\verb|0.6788e-5|)}:

Henry constant for N2 \verb+[mol/m3/Pa]+
 (found in file: \verb+../applications/advdif/gaschem.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{KO@\verb+KO+}
\item\verb+double KO+ {\rm(default=\verb|1.3516e-5|)}:

Henry constant for O2 \verb+[mol/m3/Pa]+
 (found in file: \verb+../applications/advdif/gaschem.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{KSP\_method@\verb+KSP_method+}
\item\verb+string KSP_method+ {\rm(default=\verb|gmres|)}:

Defines the KSP method
 (found in file: \verb+../src/iisdmat.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{Krylov\_dim@\verb+Krylov_dim+}
\item\verb+int Krylov_dim+ {\rm(default=\verb|50|)}:

Krylov space dimension in solving the monolithic linear
system (Newton linear subiteration) by GMRES.
 (found in file: \verb+../src/iisdmat.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{LES@\verb+LES+}
\item\verb+int LES+ {\rm(default=\verb|0|)}:

Activates LES turbulence model
 (found in file: \verb+../applications/advdif/gasflow.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{LES@\verb+LES+}
\item\verb+int LES+ {\rm(default=\verb|0|)}:

Use the LES/Smagorinsky turbulence model. 
 (found in file: \verb+../applications/ns/ns.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{LES@\verb+LES+}
\item\verb+int LES+ {\rm(default=\verb|0|)}:

Add LES for this particular elemset.
 (found in file: \verb+../applications/ns/nsikeps.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{LES@\verb+LES+}
\item\verb+int LES+ {\rm(default=\verb|0|)}:

Add LES for this particular elemset.
 (found in file: \verb+../applications/ns/nsikepsrot.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{LES@\verb+LES+}
\item\verb+int LES+ {\rm(default=\verb|0|)}:

Add LES for this particular elemset.
 (found in file: \verb+../applications/ns/nsilesther.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{LES@\verb+LES+}
\item\verb+int LES+ {\rm(default=\verb|0|)}:

Add LES for this particular elemset.
 (found in file: \verb+../applications/ns/nsirot.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{LES@\verb+LES+}
\item\verb+int LES+ {\rm(default=\verb|0|)}:

Add LES for this particular elemset.
 (found in file: \verb+../applications/ns/nsitetlesfm2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{LES@\verb+LES+}
\item\verb+int LES+ {\rm(default=\verb|0|)}:

Add LES for this particular elemset.
 (found in file: \verb+../applications/ns/nssup.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{LES@\verb+LES+}
\item\verb+int LES+ {\rm(default=\verb|0|)}:

Add LES for this particular elemset.
 (found in file: \verb+../applications/ns/nssupg.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{Nb\_ctff@\verb+Nb_ctff+}
\item\verb+double Nb_ctff+ {\rm(default=\verb|0.0|)}:

Cutoff value for Nb
 (found in file: \verb+../applications/advdif/gaschem.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{Nb\_scale@\verb+Nb_scale+}
\item\verb+double Nb_scale+ {\rm(default=\verb|1.0|)}:

Scale Nb eq. with this
 (found in file: \verb+../applications/advdif/gaschem.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{Poisson\_ratio@\verb+Poisson_ratio+}
\item\verb+double Poisson_ratio+ {\rm(default=\verb|0.|)}:

Poisson ratio
 (found in file: \verb+../applications/ns/elast.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{Pr\_t@\verb+Pr_t+}
\item\verb+double Pr_t+ {\rm(default=\verb|1.|)}:

Turbulent Prandtl number
 (found in file: \verb+../applications/advdif/gasflow.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{Pr\_t@\verb+Pr_t+}
\item\verb+double Pr_t+ {\rm(default=\verb|1.0|)}:

turbulent Prandtl number.
 (found in file: \verb+../applications/ns/nsilesther.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{Rgas@\verb+Rgas+}
\item\verb+double Rgas+ {\rm(default=\verb|8.314|)}:

Gas constant
 (found in file: \verb+../applications/advdif/gaschem.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{Sc@\verb+Sc+}
\item\verb+double Sc+ {\rm(default=\verb|0.83|)}:

Turbulent Schmidt number
 (found in file: \verb+../applications/advdif/gaschem.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{T@\verb+T+}
\item\verb+double T+ {\rm(default=\verb|1.|)}:

The duration of the impulse
 (found in file: \verb+../src/tempfun2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{T0@\verb+T0+}
\item\verb+double T0+ {\rm(default=\verb|0.|)}:

The starting time
 (found in file: \verb+../src/tempfun2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{Tgas@\verb+Tgas+}
\item\verb+double Tgas+ {\rm(default=\verb|293.0|)}:

Gas temperature
 (found in file: \verb+../applications/advdif/gaschem.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{Tinfty@\verb+Tinfty+}
\item\verb+double Tinfty+ {\rm(default=\verb|0.|)}:

Reference temperature for thermal coupling Boussinesq term
 (found in file: \verb+../applications/ns/nsilesther.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{Young\_modulus@\verb+Young_modulus+}
\item\verb+double Young_modulus+ {\rm(default=\verb|0.|)}:

Young modulus
 (found in file: \verb+../applications/ns/elast.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{a\_bar@\verb+a_bar+}
\item\verb+double a_bar+ {\rm(default=\verb|1.|)}:

Unit conversion factor for Manning friction law.
 (found in file: \verb+../applications/advdif/stream.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{activate\_debug@\verb+activate_debug+}
\item\verb+int activate_debug+ {\rm(default=\verb|0|)}:

Activate debugging
 (found in file: \verb+../applications/advdif/advdif.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{activate\_debug@\verb+activate_debug+}
\item\verb+int activate_debug+ {\rm(default=\verb|0|)}:

Activate debugging
 (found in file: \verb+../applications/advdif/advdif_bubbly.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{activate\_debug@\verb+activate_debug+}
\item\verb+int activate_debug+ {\rm(default=\verb|0|)}:

Activate debugging
 (found in file: \verb+../applications/ns/ns.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{activate\_debug\_memory\_usage@\verb+activate_debug_memory_usage+}
\item\verb+int activate_debug_memory_usage+ {\rm(default=\verb|0|)}:

Activate report of memory usage
 (found in file: \verb+../applications/advdif/advdif.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{activate\_debug\_memory\_usage@\verb+activate_debug_memory_usage+}
\item\verb+int activate_debug_memory_usage+ {\rm(default=\verb|0|)}:

Activate report of memory usage
 (found in file: \verb+../applications/advdif/advdif_bubbly.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{activate\_debug\_memory\_usage@\verb+activate_debug_memory_usage+}
\item\verb+int activate_debug_memory_usage+ {\rm(default=\verb|0|)}:

Activate report of memory usage
 (found in file: \verb+../applications/ns/ns.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{activate\_debug\_print@\verb+activate_debug_print+}
\item\verb+int activate_debug_print+ {\rm(default=\verb|0|)}:

Activate printing in debugging
 (found in file: \verb+../applications/advdif/advdif.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{activate\_debug\_print@\verb+activate_debug_print+}
\item\verb+int activate_debug_print+ {\rm(default=\verb|0|)}:

Activate printing in debugging
 (found in file: \verb+../applications/advdif/advdif_bubbly.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{activate\_debug\_print@\verb+activate_debug_print+}
\item\verb+int activate_debug_print+ {\rm(default=\verb|0|)}:

Activate printing in debugging
 (found in file: \verb+../applications/ns/ns.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{additional\_iprops@\verb+additional_iprops+}
\item\verb+int additional_iprops+ {\rm(default=\verb|0|)}:

int additional properties (used by the element routine)
 (found in file: \verb+../src/readmesh.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{additional\_props@\verb+additional_props+}
\item\verb+int additional_props+ {\rm(default=\verb|0|)}:

Additional properties (used by the element routine)
 (found in file: \verb+../src/readmesh.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{additional\_tau\_pspg@\verb+additional_tau_pspg+}
\item\verb+double additional_tau_pspg+ {\rm(default=\verb|0.|)}:

Add to the \verb+tau_pspg+ term, so that you can stabilize with a term
 independently of $h$. (Mainly for debugging purposes). 
 (found in file: \verb+../applications/ns/nsitetlesfm2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\item\verb+ double[var_len]+ \verb+ advective_jacobians+ {\rm(default=\verb| no default|)}:
 
Jacobian of advective fluxes. That means 

\begin{equation} 
   A_{j\mu\nu} = \dep {\F^\conv_{i\mu}}{U_\nu}
\end{equation}

The full jacobian has \verb+ndim*ndof*ndof+ components, but in many
cases the Jacobian is not full. The following cases are considered. 
%
\begin{itemize}

\item{\alltt null}: (\verb+var_len=0+) This means $A\equiv 0$. No
advection term is present.

%<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*> 
\item{\alltt global_vector} (\verb+var_len=ndim+) This means a vector
that is constant for all fields: $A_{j\mu\nu} = u_j \,
\delta_{\mu\nu}$. 

%<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*> 
\item{\alltt vector_per_field} (\verb+var_len=ndof*ndim+) This means a vector
for each field: 
%
\begin{equation}
  A_{j\mu\nu} = {\bar u}_{j\mu} \, \delta_{\mu\nu} \text{(No sum over $\mu$)}
\end{equation}
%
The values of $\bar u$ are entered in order 
\(\{\{{\bar u}_{j\mu}\},j=1,\ndim\},\mu=1,\ndof\}\). 

%<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*> 
\item{\alltt full} (\verb+var_len=ndof*ndof*ndim+) 
The values of the full advective jacobians are entered in the order 
\(\{\{\{A_{j\mu\nu}\},\nu=1,\ndof\},\mu=1,\ndof\},j=1,\ndim\}\). 
\end{itemize}

%<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*> 

Which of the several possibilities is chosen depends on the size of
the vector entered and on the string value of the option
\verb+advective_jacobians_type+, according to the following rules:

\begin{enumerate}
\item If the option \verb+advective_jacobians_type+ is explicitly
entered, then the size of the entered data vector must agree with the
value of \verb+var_len+ given above. If this is not so, an error is
issued. 

\item Otherwise, the corresponding jacobian type is determined from
the length of the vector entered according to the first type that
matches \verb+var_len+. If no type matches an error is issued. 

\item If both lines \verb+advective_jacobians_type+ and
\verb+advective_jacobians+ are missing, then a \verb+null+ jacobian is
assumed. 
\end{enumerate}

Some examples follow:

\begin{itemize}
\item For instance if $\ndim=2$ and $\ndof=3$ then the following lines
%
\begin{verbatim}
advective_jacobians_type "full"
advective_jacobians \
    3.281371 0.547628 1.146676  \
    0.547628 0.075290 -0.599221  \
    1.146676 -0.599221 1.436927  \
    -0.685102 -0.089878 -1.024710  \
    -0.089878 0.086971 0.468728  \
    -1.024710 0.468728 0.109558  
\end{verbatim}
%
means a full jacobian so that \(!A_x = A_{1\,.\,\,.\ }\) and \(!A_y =
A_{2\,.\,\,.\ }\) are
%
\begin{equation} 
\begin{split}
!A_x &= \begin{sqmat}{ccc}
    3.281371 & 0.547628 &1.146676  \\
    0.547628 &0.075290 &-0.599221  \\
    1.146676 &-0.599221 &1.436927 
       \end{sqmat} \\
!A_y &= \begin{sqmat}{ccc}
    -0.685102 &-0.089878 &-1.024710  \\
    -0.089878 &0.086971 &0.468728  \\
    -1.024710 &0.468728 &0.109558  
       \end{sqmat} \\
\end{split}
\end{equation}

\item If the folowing line are entered, instead:
%
\begin{verbatim}
advective_jacobians_type "full"
advective_jacobians \
    3.281371 0.547628 1.146676  \
    0.547628 0.075290 -0.599221 
\end{verbatim}
%
an error condition is issued, since even if the number of values
entered (\verb+var_len=6+) matches for the ``\verb+vector_per_field+'' 
jacobian type, this doesn't agree with the type requested in the
``\verb+advective_jacobians_type+'' entry. 

\item However, if the ``\verb+advective_jacobians_type+'' line is
removed, then a ``\verb+vector_per_field+'' type is assumed, and no
error condition is generated. 

\end{itemize}

% If of length \verb+double[ndim]+ then it
% is a velocity vector equal for all fields (stored in the order $u_i,
% i=1,\dots,\ndim$).  If of length \verb+double[ndim*ndof]+ then it is a
% velocity vector per field (stored in the order
% $u^1_1,\ldots,u^1_\ndim,\ldots,u^\ndof_1,\ldots,u^\ndof_\ndim$). If of
% length \verb+double[ndim*ndof*ndof]+ then it is a
% \verb+ndof*ndof*ndof+ matrix per dimension (stored in order
% $!A^1,\ldots,!A^\ndim$, where each jacobian is stored by rows.)
  (found in file: \verb+../applications/advdif/ffadvfm2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\item\verb+ double[ndim]/double[ndim*ndof]/double[ndim*ndof*ndof]+ \verb+ advective_jacobians+ {\rm(default=\verb| no default|)}:
 
Jacobian of advective fluxes. That means 

\begin{equation} 
   A_{j\mu\nu} = \dep {\F^\conv_{i\mu}}{U_\nu}
\end{equation}

The full jacobian has \verb+ndim*ndof*ndof+ components, but in many
cases the Jacobian is not full. The following cases are considered. 
%
\begin{itemize}

\item{\alltt null}: (\verb+var_len=0+) This means $A\equiv 0$. No
advection term is present.

%<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*> 
\item{\alltt global_vector} (\verb+var_len=ndim+) This means a vector
that is constant for all fields: $A_{j\mu\nu} = u_j \,
\delta_{\mu\nu}$. 

%<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*> 
\item{\alltt vector_per_field} (\verb+var_len=ndof*ndim+) This means a vector
for each field: 
%
\begin{equation}
  A_{j\mu\nu} = {\bar u}_{j\mu} \, \delta_{\mu\nu} \text{(No sum over $\mu$)}
\end{equation}
%
The values of $\bar u$ are entered in order 
\(\{\{{\bar u}_{j\mu}\},j=1,\ndim\},\mu=1,\ndof\}\). 

%<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*> 
\item{\alltt full} (\verb+var_len=ndof*ndof*ndim+) 
The values of the full advective jacobians are entered in the order 
\(\{\{\{A_{j\mu\nu}\},\nu=1,\ndof\},\mu=1,\ndof\},j=1,\ndim\}\). 
\end{itemize}

%<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*> 

Which of the several possibilities is chosen depends on the size of
the vector entered and on the string value of the option
\verb+advective_jacobians_type+, according to the following rules:

\begin{enumerate}
\item If the option \verb+advective_jacobians_type+ is explicitly
entered, then the size of the entered data vector must agree with the
value of \verb+var_len+ given above. If this is not so, an error is
issued. 

\item Otherwise, the corresponding jacobian type is determined from
the length of the vector entered according to the first type that
matches \verb+var_len+. If no type matches an error is issued. 

\item If both lines \verb+advective_jacobians_type+ and
\verb+advective_jacobians+ are missing, then a \verb+null+ jacobian is
assumed. 
\end{enumerate}

Some examples follow:

\begin{itemize}
\item For instance if $\ndim=2$ and $\ndof=3$ then the following lines
%
\begin{verbatim}
advective_jacobians_type "full"
advective_jacobians \
    3.281371 0.547628 1.146676  \
    0.547628 0.075290 -0.599221  \
    1.146676 -0.599221 1.436927  \
    -0.685102 -0.089878 -1.024710  \
    -0.089878 0.086971 0.468728  \
    -1.024710 0.468728 0.109558  
\end{verbatim}
%
means a full jacobian so that \(!A_x = A_{1\,.\,\,.\ }\) and \(!A_y =
A_{2\,.\,\,.\ }\) are
%
\begin{equation} 
\begin{split}
!A_x &= \begin{sqmat}{ccc}
    3.281371 & 0.547628 &1.146676  \\
    0.547628 &0.075290 &-0.599221  \\
    1.146676 &-0.599221 &1.436927 
       \end{sqmat} \\
!A_y &= \begin{sqmat}{ccc}
    -0.685102 &-0.089878 &-1.024710  \\
    -0.089878 &0.086971 &0.468728  \\
    -1.024710 &0.468728 &0.109558  
       \end{sqmat} \\
\end{split}
\end{equation}

\item If the folowing line are entered, instead:
%
\begin{verbatim}
advective_jacobians_type "full"
advective_jacobians \
    3.281371 0.547628 1.146676  \
    0.547628 0.075290 -0.599221 
\end{verbatim}
%
an error condition is issued, since even if the number of values
entered (\verb+var_len=6+) matches for the ``\verb+vector_per_field+'' 
jacobian type, this doesn't agree with the type requested in the
``\verb+advective_jacobians_type+'' entry. 

\item However, if the ``\verb+advective_jacobians_type+'' line is
removed, then a ``\verb+vector_per_field+'' type is assumed, and no
error condition is generated. 

\end{itemize}

% If of length \verb+double[ndim]+ then it
% is a velocity vector equal for all fields (stored in the order $u_i,
% i=1,\dots,\ndim$).  If of length \verb+double[ndim*ndof]+ then it is a
% velocity vector per field (stored in the order
% $u^1_1,\ldots,u^1_\ndim,\ldots,u^\ndof_1,\ldots,u^\ndof_\ndim$). If of
% length \verb+double[ndim*ndof*ndof]+ then it is a
% \verb+ndof*ndof*ndof+ matrix per dimension (stored in order
% $!A^1,\ldots,!A^\ndim$, where each jacobian is stored by rows.)
  (found in file: \verb+../applications/advdif/ffadvfm2_old.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{advective\_jacobians\_type@\verb+advective_jacobians_type+}
\item\verb+string advective_jacobians_type+ {\rm(default=\verb|string("undefined")|)}:

Set advective jacobian to the desired type. May be one of 
``\verb+null+'', ``\verb+global_vector+'',
``\verb+vector_per_field+'' or ``\verb+full+''. 
See documentation for the \verb+advective_jacobians+ option. 
 (found in file: \verb+../applications/advdif/ffadvfm2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{alpha@\verb+alpha+}
\item\verb+double alpha+ {\rm(default=\verb|1.|)}:

The parameter of the trapezoidal rule
for temporal integration. 
 (found in file: \verb+../applications/advdif/advdif.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{alpha@\verb+alpha+}
\item\verb+double alpha+ {\rm(default=\verb|0.|)}:

The parameter of the trapezoidal rule
for temporal integration. 
 (found in file: \verb+../applications/advdif/advdif_bubbly.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{alpha@\verb+alpha+}
\item\verb+double alpha+ {\rm(default=\verb|1.|)}:

Trapezoidal method parameter. \verb+alpha=1+:
Backward Euler. \verb+alpha=0+: Forward Euler.
\verb+alpha=0.5+: Crank-Nicholson. 
 (found in file: \verb+../applications/ns/ns.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{alpha@\verb+alpha+}
\item\verb+double alpha+ {\rm(default=\verb|1.|)}:

Parameter for the trapezoidal rule time integration method.
 (found in file: \verb+../applications/ns/nsilesther.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{aquifer\_phi\_dof@\verb+aquifer_phi_dof+}
\item\verb+int aquifer_phi_dof+ {\rm(default=\verb|1|)}:

We can have the \verb+phi+ dof of the aquifer to be
 any of the dofs there. This indx flags which of the dof's
 of the aquifer is the \verb+phi+ (piezometric height) field. 
 (found in file: \verb+../applications/advdif/aquifer.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{atol@\verb+atol+}
\item\verb+double atol+ {\rm(default=\verb|1e-6|)}:

Absolute tolerance when solving a consistent matrix
 (found in file: \verb+../applications/advdif/advdif.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{atol@\verb+atol+}
\item\verb+double atol+ {\rm(default=\verb|1e-6|)}:

Absolute tolerance when solving a consistent matrix
 (found in file: \verb+../applications/advdif/advdif_bubbly.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{atol@\verb+atol+}
\item\verb+double atol+ {\rm(default=\verb|1e-6|)}:

Absolute tolerance when solving a consistent matrix
 (found in file: \verb+../applications/advective/adv.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{atol@\verb+atol+}
\item\verb+double atol+ {\rm(default=\verb|1e-6|)}:

Absolute tolerance to solve the monolithic linear
system (Newton linear subiteration).
 (found in file: \verb+../src/iisdmat.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{auto\_time\_step@\verb+auto_time_step+}
\item\verb+int auto_time_step+ {\rm(default=\verb|1|)}:

Chooses automatically the time step from the 
selected Courant number
 (found in file: \verb+../applications/advdif/advdif.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{auto\_time\_step@\verb+auto_time_step+}
\item\verb+int auto_time_step+ {\rm(default=\verb|1|)}:

Chooses automatically the time step from the 
selected Courant number
 (found in file: \verb+../applications/advdif/advdif_bubbly.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{auto\_time\_step@\verb+auto_time_step+}
\item\verb+int auto_time_step+ {\rm(default=\verb|1|)}:

Chooses automatically the time step from the 
selected Courant number
 (found in file: \verb+../applications/advective/adv.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{axisymmetric@\verb+axisymmetric+}
\item\verb+string axisymmetric+ {\rm(default=\verb|"none"|)}:

Add axisymmetric version for this particular elemset.
 (found in file: \verb+../applications/advdif/advdife.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{axisymmetric@\verb+axisymmetric+}
\item\verb+string axisymmetric+ {\rm(default=\verb|"none"|)}:

Add axisymmetric version for this particular elemset.
 (found in file: \verb+../applications/advdif/pfcpp_temp.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{axisymmetric@\verb+axisymmetric+}
\item\verb+string axisymmetric+ {\rm(default=\verb|none|)}:

Add axisymmetric version for this particular elemset.
 (found in file: \verb+../applications/ns/nsikeps.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{axisymmetric@\verb+axisymmetric+}
\item\verb+string axisymmetric+ {\rm(default=\verb|none|)}:

Add axisymmetric version for this particular elemset.
 (found in file: \verb+../applications/ns/nsikepsrot.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{axisymmetric@\verb+axisymmetric+}
\item\verb+string axisymmetric+ {\rm(default=\verb|none|)}:

Add axisymmetric version for this particular elemset.
 (found in file: \verb+../applications/ns/nsilesther.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{axisymmetric@\verb+axisymmetric+}
\item\verb+int axisymmetric+ {\rm(default=\verb|0|)}:

Axisymmetric flag
 (found in file: \verb+../applications/ns/nsirot.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{axisymmetric@\verb+axisymmetric+}
\item\verb+string axisymmetric+ {\rm(default=\verb|none|)}:

Add axisymmetric version for this particular elemset.
 (found in file: \verb+../applications/ns/nsitetlesfm2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{base@\verb+base+}
\item\verb+double base+ {\rm(default=\verb|0.|)}:

The base value for the Gaussian
 (found in file: \verb+../src/tempfun2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{base@\verb+base+}
\item\verb+double base+ {\rm(default=\verb|0.|)}:

base value
 (found in file: \verb+../src/tempfun2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{beta\_supg@\verb+beta_supg+}
\item\verb+double beta_supg+ {\rm(default=\verb|1.|)}:

Weights the temporal term with $N+\beta P$, i.e.
$\beta=0$ is equivalent to waight the temporal term a la
Galerkin and $\beta=1$ is equivalent to do the consistent SUPG weighting.
 (found in file: \verb+../applications/advdif/advdife.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{beta\_supg@\verb+beta_supg+}
\item\verb+double beta_supg+ {\rm(default=\verb|1.|)}:

Weights the temporal term with $N+\beta P$, i.e.
$\beta=0$ is equivalent to waight the temporal term a la 
Galerkin and $\beta=1$ is equivalent to do the consistent SUPG weighting.
 (found in file: \verb+../applications/advdif/advdifeo.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{beta\_supg@\verb+beta_supg+}
\item\verb+double beta_supg+ {\rm(default=\verb|1.|)}:

Weights the temporal term with $N+\beta P$, i.e.
$\beta=0$ is equivalent to waight the temporal term a la
Galerkin and $\beta=1$ is equivalent to do the consistent SUPG weighting.
 (found in file: \verb+../applications/advdif/pfcpp_temp.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{beta\_supg@\verb+beta_supg+}
\item\verb+double beta_supg+ {\rm(default=\verb|0.8|)}:

Parameter to control the amount of SUPG perturbation 
    added to the mass matrix to be consistent SUPG
    \verb+beta_supg+=0 implies consistent Galerkin and
    \verb+beta_supg+=1 implies full consistent SUPG. 
 (found in file: \verb+../applications/advective/advecfm2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{beta\_supg@\verb+beta_supg+}
\item\verb+double beta_supg+ {\rm(default=\verb|0.8|)}:

Parameter to control the amount of SUPG perturbation 
    added to the mass matrix to be consistent SUPG
    \verb+beta_supg+=0 implies consistent Galerkin and
    \verb+beta_supg+=1 implies full consistent SUPG. 
 (found in file: \verb+../applications/advective/advective.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{betath@\verb+betath+}
\item\verb+double betath+ {\rm(default=\verb|0.|)}:

buoyancy coefficient for Boussinesq term
 (found in file: \verb+../applications/ns/nsilesther.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{block\_uploading@\verb+block_uploading+}
\item\verb+int block_uploading+ {\rm(default=\verb|1|)}:

Use Fast up-loading method or not 
 (found in file: \verb+../src/elmsupl.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{bottom\_length@\verb+bottom_length+}
\item\verb+double bottom_length+ {\rm(default=\verb|0.|)}:

Reference volume. Fluxes are injected to the bottom in order
 to reach this value/
 (found in file: \verb+../test/spillway/alehook.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{c\_distor@\verb+c_distor+}
\item\verb+double c_distor+ {\rm(default=\verb|1.|)}:

Scales distortion function
 (found in file: \verb+../applications/ns/mmove.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{c\_relax@\verb+c_relax+}
\item\verb+double c_relax+ {\rm(default=\verb|1.|)}:

Compute an initial ``predictor'' step with this relaxation scale. 
 (found in file: \verb+../applications/ns/mmove.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{c\_volume@\verb+c_volume+}
\item\verb+double c_volume+ {\rm(default=\verb|0.|)}:

Adds a term $\propto {\tt c\_volume}\,{\rm volume}$ to the functionala. 
 (found in file: \verb+../applications/ns/mmove.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{cache\_grad\_div\_u@\verb+cache_grad_div_u+}
\item\verb+int cache_grad_div_u+ {\rm(default=\verb|0|)}:

Cache \verb+grad_div_u+ matrix
 (found in file: \verb+../applications/ns/nsikeps.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{cache\_grad\_div\_u@\verb+cache_grad_div_u+}
\item\verb+int cache_grad_div_u+ {\rm(default=\verb|0|)}:

Cache \verb+grad_div_u+ matrix
 (found in file: \verb+../applications/ns/nsikepsrot.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{cache\_grad\_div\_u@\verb+cache_grad_div_u+}
\item\verb+int cache_grad_div_u+ {\rm(default=\verb|0|)}:

Cache \verb+grad_div_u+ matrix
 (found in file: \verb+../applications/ns/nsilesther.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{cache\_grad\_div\_u@\verb+cache_grad_div_u+}
\item\verb+int cache_grad_div_u+ {\rm(default=\verb|0|)}:

Cache \verb+grad_div_u+ matrix
 (found in file: \verb+../applications/ns/nsirot.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{cache\_grad\_div\_u@\verb+cache_grad_div_u+}
\item\verb+int cache_grad_div_u+ {\rm(default=\verb|0|)}:

Cache \verb+grad_div_u+ matrix
 (found in file: \verb+../applications/ns/nsitetlesfm2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{called\_from\_rosi@\verb+called_from_rosi+}
\item\verb+int called_from_rosi+ {\rm(default=\verb|0|)}:

Is being PETSc-FEM called from ROSI?
 (found in file: \verb+../applications/ns/nssupr.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{check\_dofmap\_id@\verb+check_dofmap_id+}
\item\verb+int check_dofmap_id+ {\rm(default=\verb|0|)}:

Checks that the \verb+idmap+ has been correctly generated. 
 (found in file: \verb+../src/readmesh.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{chunk\_size@\verb+chunk_size+}
\item\verb+int chunk_size+ {\rm(default=\verb|ELEM_CHUNK_SIZE|)}:

Chunk size for the elemset. 
 (found in file: \verb+../src/elemset.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{coef\_file@\verb+coef_file+}
\item\verb+string coef_file+ {\rm(default=\verb|"coef_file.dat"|)}:

The file containing coefficients
 (found in file: \verb+../applications/ns/nsres.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{compact\_profile\_graph\_chunk\_size@\verb+compact_profile_graph_chunk_size+}
\item\verb+int compact_profile_graph_chunk_size+ {\rm(default=\verb|0|)}:

Size of chunk for the dynamic vector used in computing the
mstrix profile. 
 (found in file: \verb+../src/iisdmat.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{compute\_fd\_adv\_jacobian@\verb+compute_fd_adv_jacobian+}
\item\verb+int compute_fd_adv_jacobian+ {\rm(default=\verb|0|)}:

Compute finite difference jacobian of fluxes for checking the
 analytical one. For each element the following norms are printed:
 analytical jacobian \verb+|A_a|+ , numerical jacobian \verb+|A_n|+ and te
 difference \verb+|A_a-A_n|+ . Incrementing \verb+compute_fd_adv_jacobian==1+
 increases the verbosity. If \verb+=1+ the maximum values over all the
 elemset are printed. If \verb+=2+ the errors for all elements are
 reported. Finally, if \verb+=3+ also the jacobians themselves are
 printed. For 2 and 3, if \verb+compute_fd_adv_jacobian_elem_list+ is
 set, then only those elements are printed. If
 \verb+compute_fd_adv_jacobian_rel_err_threshold+ is set then only those
 elements for which the error is greater than the given threshold
 are reported.  Also, be warned that when run in parallel, printing
 for a lot of elements in different processors may be messy.
 (found in file: \verb+../applications/advdif/advdife.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{compute\_fd\_adv\_jacobian@\verb+compute_fd_adv_jacobian+}
\item\verb+int compute_fd_adv_jacobian+ {\rm(default=\verb|0|)}:

Compute finite difference jacobian of fluxes for checking the
 analytical one. For each element the following norms are printed:
 analytical jacobian \verb+|A_a|+ , numerical jacobian \verb+|A_n|+ and te
 difference \verb+|A_a-A_n|+ . Incrementing \verb+compute_fd_adv_jacobian==1+
 increases the verbosity. If \verb+=1+ the maximum values over all the
 elemset are printed. If \verb+=2+ only those whose relative errors are
 greater than \verb+compute_fd_adv_jacobian_rel_err_threshold+ are
 reported. If \verb+=3+ the errors for all elements are
 reported. Finally, if \verb+=4+ also the jacobians themselves are
 printed. For 3 and 4, if \verb+compute_fd_adv_jacobian_elem_list+ is
 set, then only those elements are printed. Also, be warned that when
 run in parallel, printing for a lot of elements in different
 processors may be messy.
 (found in file: \verb+../applications/advdif/pfcpp_temp.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{compute\_fd\_adv\_jacobian\_eps@\verb+compute_fd_adv_jacobian_eps+}
\item\verb+double compute_fd_adv_jacobian_eps+ {\rm(default=\verb|1e-4|)}:

The perturbation scale for computing the numerical jacobian
 (see \verb+compute_fd_adv_jacobian+ ).
 (found in file: \verb+../applications/advdif/advdife.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{compute\_fd\_adv\_jacobian\_eps@\verb+compute_fd_adv_jacobian_eps+}
\item\verb+double compute_fd_adv_jacobian_eps+ {\rm(default=\verb|1e-4|)}:

The perturbation scale for computing the numerical jacobian
 (see \verb+compute_fd_adv_jacobian+ ).
 (found in file: \verb+../applications/advdif/pfcpp_temp.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{compute\_fd\_adv\_jacobian\_random@\verb+compute_fd_adv_jacobian_random+}
\item\verb+double compute_fd_adv_jacobian_random+ {\rm(default=\verb|1.0|)}:

Report jacobians on random elements (should be in range 0-1).
 (found in file: \verb+../applications/advdif/advdife.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{compute\_fd\_adv\_jacobian\_rel\_err\_threshold@\verb+compute_fd_adv_jacobian_rel_err_threshold+}
\item\verb+double compute_fd_adv_jacobian_rel_err_threshold+ {\rm(default=\verb|0.|)}:

Report elements whose relative error in computing
 flux jacobians exceed these value. 
 (found in file: \verb+../applications/advdif/advdife.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{compute\_fd\_adv\_jacobian\_rel\_err\_threshold@\verb+compute_fd_adv_jacobian_rel_err_threshold+}
\item\verb+double compute_fd_adv_jacobian_rel_err_threshold+ {\rm(default=\verb|1e-4|)}:

Report elements whose relative error in computing
 flux jacobians exceed these value. 
 (found in file: \verb+../applications/advdif/pfcpp_temp.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{conductivity@\verb+conductivity+}
\item\verb+double conductivity+ {\rm(default=\verb|1.|)}:

Thermal conductivity
 (found in file: \verb+../applications/ns/qharm.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{consistent\_supg\_matrix@\verb+consistent_supg_matrix+}
\item\verb+int consistent_supg_matrix+ {\rm(default=\verb|0|)}:

Uses consistent SUPG matrix for the temporal term or not. 
 (found in file: \verb+../applications/advdif/advdif.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{consistent\_supg\_matrix@\verb+consistent_supg_matrix+}
\item\verb+int consistent_supg_matrix+ {\rm(default=\verb|0|)}:

Uses consistent SUPG matrix for the temporal term or not. 
 (found in file: \verb+../applications/advdif/advdif_bubbly.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{consistent\_supg\_matrix@\verb+consistent_supg_matrix+}
\item\verb+int consistent_supg_matrix+ {\rm(default=\verb|0|)}:

Uses consistent SUPG matrix for the temporal term or not. 
 (found in file: \verb+../applications/advective/adv.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{cyclic\_fs@\verb+cyclic_fs+}
\item\verb+int cyclic_fs+ {\rm(default=\verb|0|)}:

Assume problem is periodic 
 (found in file: \verb+../test/spillway/alehook.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{cyclic\_length@\verb+cyclic_length+}
\item\verb+double cyclic_length+ {\rm(default=\verb|0|)}:

Assume problem is periodic 
 (found in file: \verb+../test/spillway/alehook.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{debug\_compute\_prof@\verb+debug_compute_prof+}
\item\verb+int debug_compute_prof+ {\rm(default=\verb|0|)}:

Debug the process of building the matrix profile. 
 (found in file: \verb+../src/elemset.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{debug\_compute\_prof@\verb+debug_compute_prof+}
\item\verb+int debug_compute_prof+ {\rm(default=\verb|0|)}:

Print the profile 
 (found in file: \verb+../src/petscmat.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{debug\_element\_partitioning@\verb+debug_element_partitioning+}
\item\verb+int debug_element_partitioning+ {\rm(default=\verb|0|)}:

Prints element partitioning. 
 (found in file: \verb+../src/readmesh.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{density@\verb+density+}
\item\verb+double density+ {\rm(default=\verb|0.|)}:

Density
 (found in file: \verb+../applications/ns/elast.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{dev\_comp\_mask@\verb+dev_comp_mask+}
\item\verb+double dev_comp_mask+ {\rm(default=\verb|1.|)}:

Mask for deviatoric component of stress tensor 
 (found in file: \verb+../applications/ns/embgath.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\item\verb+ double[var_len]+ \verb+ diffusive_jacobians+ {\rm(default=\verb| no default|)}:
 
Jacobian of diffusive fluxes, i.e. 
\(\F^{\diff\mu}_i = \D_{ij\mu\nu}\, \prt_j U^\nu\). 
%
The full jacobian has \verb+ndim*ndim*ndof*ndof+ components, but in many
cases the Jacobian is not full. The following cases are
considered. (See the description for the \verb+advective_jacobians+
entry). 
%
\begin{itemize}
%
\item{\alltt null}: (\verb+var_len=0+) This means $D\equiv 0$. No
diffusion term is present. Beware that this can lead (but not
necessarily) to singularities. 

\item {\alltt global_scalar} {\alltt [var\_len==1]} (A scalar) 
Isotropic diffusivity, the same
for all fields (\(\D_{ij}^{\mu\nu} = \bar{\D} \, \delta^{\mu\nu} \,
\delta_{ij}\)).
%
\item{\alltt global_tensor} {\alltt [var_len==ndim*ndim]}] Diffusivity tensor
equal for all fields (\(\D_{ij}^{\mu\nu} = \bD_{ij} \,
\delta^{\mu\nu}\)) stored by rows (\(\{\{\bD_{ij},j=1,\ndim\},i=1,\ndim\}\)).
%
\item{\alltt scalar_per_field} [{\alltt [var_len==ndof]}] 
A scalar diffusivity per field (\(\D_{ij}^{\mu\nu} = {\bD_\mu} \,
\delta^{\mu\nu} \, \delta^{ij}\), no sum over \(\mu\)). 
%
\item{\alltt tensor_per_field} [{\alltt [var_len==ndim*ndim*ndof]}] 
Diffusivity tensor per field (\(\D_{ij}^{\mu\nu} = {\bD_{ij}^\mu} \,
\delta^{\mu\nu}\)) stored \(\{\{\{\bD_{ij}^\mu,j=1,\ndim\},i=1,\ndim\},\mu=1,\ndof\}\).
%
\item{\alltt full} {\alltt [var_len==ndim*ndim*ndof*ndof]}] General case,
stored in order
\(\{\{\{\{\D_{ij}^{\mu\nu},j=1,\ndim\},i=1,\ndim\},\nu=1,\ndof\},\mu=1,\ndof\}\).
\end{itemize}

Which of the several possibilities is chosen depends on the size of
the vector entered and on the string value of the option
\verb+diffusive_jacobians_type+, according to the rules described in
the \verb+advective_jacobians+ option documentation. 

  (found in file: \verb+../applications/advdif/ffadvfm2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\item\verb+ double[var_len]+ \verb+ diffusive_jacobians+ {\rm(default=\verb| no default|)}:
 
Jacobian of diffusive fluxes, i.e. 
\(\F^{\diff\mu}_i = \D_{ij\mu\nu}\, \prt_j U^\nu\). 
%
The full jacobian has \verb+ndim*ndim*ndof*ndof+ components, but in many
cases the Jacobian is not full. The following cases are
considered. (See the description for the \verb+advective_jacobians+
entry). 
%
\begin{itemize}
%
\item{\alltt null}: (\verb+var_len=0+) This means $D\equiv 0$. No
diffusion term is present. Beware that this can lead (but not
necessarily) to singularities. 

\item {\alltt global_scalar} {\alltt [var\_len==1]} (A scalar) 
Isotropic diffusivity, the same
for all fields (\(\D_{ij}^{\mu\nu} = \bar{\D} \, \delta^{\mu\nu} \,
\delta_{ij}\)).
%
\item{\alltt global_tensor} {\alltt [var_len==ndim*ndim]}] Diffusivity tensor
equal for all fields (\(\D_{ij}^{\mu\nu} = \bD_{ij} \,
\delta^{\mu\nu}\)) stored by rows (\(\{\{\bD_{ij},j=1,\ndim\},i=1,\ndim\}\)).
%
\item{\alltt scalar_per_field} [{\alltt [var_len==ndof]}] 
A scalar diffusivity per field (\(\D_{ij}^{\mu\nu} = {\bD_\mu} \,
\delta^{\mu\nu} \, \delta^{ij}\), no sum over \(\mu\)). 
%
\item{\alltt tensor_per_field} [{\alltt [var_len==ndim*ndim*ndof]}] 
Diffusivity tensor per field (\(\D_{ij}^{\mu\nu} = {\bD_{ij}^\mu} \,
\delta^{\mu\nu}\)) stored \(\{\{\{\bD_{ij}^\mu,j=1,\ndim\},i=1,\ndim\},\mu=1,\ndof\}\).
%
\item{\alltt full} {\alltt [var_len==ndim*ndim*ndof*ndof]}] General case,
stored in order
\(\{\{\{\{\D_{ij}^{\mu\nu},j=1,\ndim\},i=1,\ndim\},\nu=1,\ndof\},\mu=1,\ndof\}\).
\end{itemize}

Which of the several possibilities is chosen depends on the size of
the vector entered and on the string value of the option
\verb+diffusive_jacobians_type+, according to the rules described in
the \verb+advective_jacobians+ option documentation. 

  (found in file: \verb+../applications/advdif/ffadvfm2_old.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{diffusive\_jacobians\_type@\verb+diffusive_jacobians_type+}
\item\verb+string diffusive_jacobians_type+ {\rm(default=\verb|string("undefined")|)}:

Set diffusive jacobian to the desired type
 May be one of 
``\verb+null+'', 
``\verb+global_scalar+'', ``\verb+global_tensor+'', 
``\verb+tensor_per_field+'', ``\verb+scalar_per_field+''
  or ``\verb+null+''
See documentation for the \verb+diffusive_jacobians+ option. 
 (found in file: \verb+../applications/advdif/ffadvfm2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{diffusivity@\verb+diffusivity+}
\item\verb+double diffusivity+ {\rm(default=\verb|0.|)}:

Diffusivity (viscosity)
 (found in file: \verb+../applications/advdif/ffburg.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{diffusivity@\verb+diffusivity+}
\item\verb+double diffusivity+ {\rm(default=\verb|0.|)}:

Diffusivity (viscosity)
 (found in file: \verb+../applications/advdif/ffburg_old.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{displ\_factor@\verb+displ_factor+}
\item\verb+double displ_factor+ {\rm(default=\verb|0.1|)}:

Scales displacement for ALE-like mesh relocation. 
 (found in file: \verb+../applications/ns/ns.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{distor\_exp@\verb+distor_exp+}
\item\verb+double distor_exp+ {\rm(default=\verb|1.|)}:

The functional to be minimized is $\Phi = \sum_{e=1,...,Nel} \phi_e^r$,
where $\phi_e = \sum_{i\neq j} (\lambda_i-\lambda_j)^2/Vol^{2/n_d}$,
and $r={\tt distor\_exp}$. 
 (found in file: \verb+../applications/ns/mmove.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{double\_layer@\verb+double_layer+}
\item\verb+int double_layer+ {\rm(default=\verb|0|)}:

Whether there is a double or single layer of nodes
 (found in file: \verb+../applications/advdif/genload.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{double\_layer@\verb+double_layer+}
\item\verb+int double_layer+ {\rm(default=\verb|0|)}:

Whether there is a double or single layer of nodes
 (found in file: \verb+../applications/ns/genload.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{dry\_aquifer\_stop@\verb+dry_aquifer_stop+}
\item\verb+int dry_aquifer_stop+ {\rm(default=\verb|0|)}:

Flag ehether to stop on dry aquifer
 (found in file: \verb+../applications/advdif/aquifer.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{dry\_aquifer\_stop@\verb+dry_aquifer_stop+}
\item\verb+int dry_aquifer_stop+ {\rm(default=\verb|0|)}:

Flag ehether to stop on dry aquifer
 (found in file: \verb+../applications/advdif/aquifer.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{dtol@\verb+dtol+}
\item\verb+double dtol+ {\rm(default=\verb|1e+3|)}:

Divergence tolerance when solving a consistent matrix
 (found in file: \verb+../applications/advdif/advdif.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{dtol@\verb+dtol+}
\item\verb+double dtol+ {\rm(default=\verb|1e+3|)}:

Divergence tolerance when solving a consistent matrix
 (found in file: \verb+../applications/advdif/advdif_bubbly.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{dtol@\verb+dtol+}
\item\verb+double dtol+ {\rm(default=\verb|1e+3|)}:

Divergence tolerance when solving a consistent matrix
 (found in file: \verb+../applications/advective/adv.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{dtol@\verb+dtol+}
\item\verb+double dtol+ {\rm(default=\verb|1e+3|)}:

Divergence tolerance to solve the monolithic linear
system (Newton linear subiteration).
 (found in file: \verb+../src/iisdmat.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{dx@\verb+dx+}
\item\verb+int dx+ {\rm(default=\verb|0|)}:

Flags whether the element should return a connection array
  for this elemset. 
 (found in file: \verb+../src/dxelmst.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{dx\_auto\_combine@\verb+dx_auto_combine+}
\item\verb+int dx_auto_combine+ {\rm(default=\verb|0|)}:

Auto generate states by combining elemsets with fields
 (found in file: \verb+../src/dxhook.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{dx\_cache\_connectivities@\verb+dx_cache_connectivities+}
\item\verb+int dx_cache_connectivities+ {\rm(default=\verb|0|)}:

Uses DX cache if possible in order to avoid sending the connectivities
 each time step or frame. Use only if the connectivities are not changing
 in your problem. 
 (found in file: \verb+../src/dxelmst.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{dx\_cache\_coords@\verb+dx_cache_coords+}
\item\verb+int dx_cache_coords+ {\rm(default=\verb|0|)}:

Uses DX cache if possible in order to avoid sending the coordinates
 each time step or frame. Use only if coordinates are not changing
 in your problem. 
 (found in file: \verb+../src/dxhook.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{dx\_coords\_scale\_factor@\verb+dx_coords_scale_factor+}
\item\verb+double dx_coords_scale_factor+ {\rm(default=\verb|1.|)}:

Coefficient affecting the new displacements read. 
 New coordinates are \verb|c0*x0+c*u| where
 \verb+c0=dx_coords_scale_factor0+, \verb+c1=dx_coords_scale_factor+,
 \verb+x0+ are the initial coordinates and \verb+u+ are the coordinates read
 from the given file. 
 (found in file: \verb+../src/dxhook.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{dx\_coords\_scale\_factor0@\verb+dx_coords_scale_factor0+}
\item\verb+double dx_coords_scale_factor0+ {\rm(default=\verb|1.|)}:

Coefficient affecting the original coordinates. See doc for
 \verb+dx_coords_scale_factor+
 (found in file: \verb+../src/dxhook.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{dx\_do\_make\_command@\verb+dx_do_make_command+}
\item\verb+int dx_do_make_command+ {\rm(default=\verb|0|)}:

If true, then issue a \verb+make dx_step=<step> dx_make_command+
 (found in file: \verb+../src/dxhook.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\item\verb+ mixed string/integer array+ \verb+ dx_indices+ {\rm(default=\verb| (none)|)}:
 
List of indices of the nodes to be passed to DX as connectivity
table. This has mainly two uses. First, note that the order the nodes
are entered in DX is not the same as in PETSc-FEM. For instance, in
PETSc-FEM the nodes of a quad are entered counter-clockwise, and, if
they are (in that order) 1, 2, 3, 4, then for DX they are entered in
the order: 1, 2, 4, 3. Secondly, DX has only four basic interpolations
(quads, cubes, triangles and tetras) so that other interpolations, as
prisms must be split in some number of these basic DX geometries.
For the more usual interpolations this is automatically generated.
The line has the following syntax, {\tt node-list dx-geometry}.  Where
{\tt node-list} is a list of (1-based) nodes and {\tt dx-geom} the
corresponding gometry. For instance, for the {\tt cartesian2d}
PETSc-FEM geometry, one could use the line {\tt 1 2 4 3 quads}. 
That element is equivalent to one quad, with a node
renumbering. (However this conversion is made automatically by
PETSc-FEM). If we wanted to split the quad in two triangles, say
triangle (1 2 3) and (3 4 1), we should enter {\tt 1 2 3 3 4 1
triangles}. As another example, the prism element may be split in 3
tetras according to the rule. {\tt 1 2 3 4 5 4 6 2 2 6 3 4
tetrahedra}. If you need to split the element in different geometries,
you can use the syntax {\tt node-list-1 dx-geom-1 node-list-2
dx-geom-2 ... node-list-n dx-geom-n}. 
% If the element may be split in only one type of
% geometry, then The number of nodes in \verb+node-list-j+ must be a multiple
% of the number of nodes in each \verb+dx_type_j+ is of the form #subel_1
% subel_2 ...  dx_type#, \verb+dx_type+ may be #quads#, #cubes#, with #k =
% nsubelem * subnel#. For instance a prism may be slit in 3 tetras with
% a line like #tetrahedra 3 4 1 2 3 4 5 4 6 2 2 6 3 4#.  For instance,
% for quads one should enter {\tt dx_indices 1 2 4 3 quads} and for
% cubes {\tt dx_indices 1 2 4 3 5 6 8 7}. [Note: DX wants 0-based
% (C-sytle) node numbers, whereas PETSc-FEM uses 1-based (Fortran
% style).  However they must be entered 1-based for this option.]
  (found in file: \verb+../src/dxelmst.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{dx\_node\_coordinates@\verb+dx_node_coordinates+}
\item\verb+string dx_node_coordinates+ {\rm(default=\verb|<none>|)}:

Mesh where updated coordinates must be read
 (found in file: \verb+../src/dxhook.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{dx\_port@\verb+dx_port+}
\item\verb+int dx_port+ {\rm(default=\verb|5314|)}:

TCP/IP port for communicating with DX ({\tt 5000 < dx\_port < 65536}). 
 (found in file: \verb+../src/dxhook.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{dx\_read\_state\_from\_file@\verb+dx_read_state_from_file+}
\item\verb+int dx_read_state_from_file+ {\rm(default=\verb|0|)}:

Read states from file instead of computing them . Normally
 this is done to analyze a previous run. If 1 the file is
 ASCII, if 2 then it is a binary file. In both cases the order
 \textbf{of the} \emph{elements must} be: \verb+u(1,1),+ \verb+u(1,2),+ \verb+u(1,3),+
 \verb+u(1,ndof),+ \verb+u(2,1),+ ... \verb+u(nnod,ndof)+ where \verb+u(i,j)+ is
 the value of field \verb+j+ at node \verb+i.+ 
 (found in file: \verb+../src/dxhook.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{dx\_split\_state@\verb+dx_split_state+}
\item\verb+string dx_split_state+ {\rm(default=\verb||)}:

Generates DX fields by combination of the input fields
 (found in file: \verb+../src/dxhook.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{dx\_state\_all\_fields@\verb+dx_state_all_fields+}
\item\verb+int dx_state_all_fields+ {\rm(default=\verb|!dx_split_state_flag|)}:

Generates a DX field with the whole state (all ndof fields)
 (found in file: \verb+../src/dxhook.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{dx\_steps@\verb+dx_steps+}
\item\verb+int dx_steps+ {\rm(default=\verb|1|)}:

Initial value for the {\tt steps} parameter. 
 (found in file: \verb+../src/dxhook.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{element\_weight@\verb+element_weight+}
\item\verb+int element_weight+ {\rm(default=\verb|1|)}:

Element weight for the processor
 (found in file: \verb+../src/elemset.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\item\verb+ double[var_len]+ \verb+ enthalpy_jacobians+ {\rm(default=\verb| no default|)}:
 
FIXME:= to be documented later
  (found in file: \verb+../applications/advdif/ffadvfm2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{enthalpy\_jacobians\_type@\verb+enthalpy_jacobians_type+}
\item\verb+string enthalpy_jacobians_type+ {\rm(default=\verb|string("undefined")|)}:

Set enthalpy jacobian to the desired type. May be one of 
``\verb+ident+'', ``\verb+global_scalar+'',
``\verb+scalar_per_field+'' or ``\verb+full+''. 
See documentation for the \verb+enthalpy_jacobians+ option. 
 (found in file: \verb+../applications/advdif/ffadvfm2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{eps\_ctff\_val@\verb+eps_ctff_val+}
\item\verb+double eps_ctff_val+ {\rm(default=\verb|1e-20|)}:

Cutoff value for $\epsilon$
 (found in file: \verb+../applications/ns/nsikeps.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{eps\_ctff\_val@\verb+eps_ctff_val+}
\item\verb+double eps_ctff_val+ {\rm(default=\verb|1e-20|)}:

Cutoff value for $\epsilon$
 (found in file: \verb+../applications/ns/nsikepsrot.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{eps\_min@\verb+eps_min+}
\item\verb+double eps_min+ {\rm(default=\verb|1e-6|)}:

Threshold value for $\epsilon$ (clip below this)
 (found in file: \verb+../applications/advdif/ffswfm1t.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{eps\_min@\verb+eps_min+}
\item\verb+double eps_min+ {\rm(default=\verb|1e-6|)}:

Threshold value for $\epsilon$ (clip below this)
 (found in file: \verb+../applications/advdif/ffswfm2t.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{epsilon\_fdj@\verb+epsilon_fdj+}
\item\verb+double epsilon_fdj+ {\rm(default=\verb|EPSILON_FDJ|)}:

The increment in the variables in order to
compute the finite difference approximation to the
Jacobian. Should be order epsilon=sqrt(precision)*(typical
magnitude of the variable). Normally, precision=1e-15 so
that epsilon=1e-7*(typical magnitude of the
variable)
 (found in file: \verb+../src/elemset.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{epsilon\_x@\verb+epsilon_x+}
\item\verb+double epsilon_x+ {\rm(default=\verb|1.e-4|)}:

Perturbation scale length for increment in computing
the Jacobian with finite differences. 
 (found in file: \verb+../applications/ns/mmove.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{expo@\verb+expo+}
\item\verb+double expo+ {\rm(default=\verb|2.|)}:

exponent of function
 (found in file: \verb+../src/tempfun2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{ext\_filename@\verb+ext_filename+}
\item\verb+string ext_filename+ {\rm(default=\verb|default|)}:

Filename of extension function
 (found in file: \verb+../src/amplidl.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{fic\_dof@\verb+fic_dof+}
\item\verb+int fic_dof+ {\rm(default=\verb|<none>|)}:

The field to be used on the fictitious node as
 Lagrange multiplier
 (found in file: \verb+../applications/ns/nullvort.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{filename@\verb+filename+}
\item\verb+string filename+ {\rm(default=\verb|piecewise_linear_data.dat|)}:

The name of the file
 (found in file: \verb+../src/tempfun2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{flux\_law\_coefficient@\verb+flux_law_coefficient+}
\item\verb+double flux_law_coefficient+ {\rm(default=\verb|1.|)}:

Flux law is $f= 0.5\,c\, \phi^2\,!u_0$, where $c$
is this coefficient. 
 (found in file: \verb+../applications/advdif/ffburg.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{flux\_law\_coefficient@\verb+flux_law_coefficient+}
\item\verb+double flux_law_coefficient+ {\rm(default=\verb|1.|)}:

Flux law is $f= 0.5\,c\, \phi^2\,!u_0$, where $c$
is this coefficient. 
 (found in file: \verb+../applications/advdif/ffburg_old.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{fractional\_step@\verb+fractional_step+}
\item\verb+int fractional_step+ {\rm(default=\verb|0|)}:

Use fractional step or TET algorithm
 (found in file: \verb+../applications/ns/ns.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{free\_surface\_damp@\verb+free_surface_damp+}
\item\verb+double free_surface_damp+ {\rm(default=\verb|0.|)}:

$\Cnst{lf}=${\tt free\_surface\_set\_level\_factor} tries to
keep the free surface level constant by adding a term $\propto
\bar\eta$ to the free surface level.  (see doc for {\tt
free\_surface\_damp})
\label{sec:free_surface}
The equation of the free surface is
%
\begin{equation} 
\dtots\eta t = w
\end{equation}
%
where $\eta$ 
elevation, and $w$ is the velocity component normal to the free
surface. We modify this as follows 
%
\begin{equation} \label{eq:fsmod}  
\Cnst{eq}\,\dtot\eta t 
   + \Cnst{lf} \bar{\eta} - \Cnst{damp} \, \Delta \eta = w
\end{equation}
%
Where $\bar\eta$ is the average value of eta on the free surface, and:
$\Cnst{damp}={\tt free\_surface\_damp}$ smoothes the free surface
adding a Laplacian filter.  Note that if only the temporal derivative
and the Laplace term are present in (\ref{eq:fsmod}) then the equation
is a heat equation. A null value (which is the default) means no
filtering. A high value means high filtering. (Warning: A high value
may result in unstability).  $\Cnst{damp}$ has dimensions of $L^2/T$
(like a diffusivity). One possibility is to scale with mesh parameters
like $h^2/\Delta t$, other is to scale with $h^{1.5} \,
g^{0.5}$. Currently, we are using $\Cnst{damp} = \Cnst{damp}' h^{1.5}
g^{0.5}$ with $\Cnst{damp}'\approx 2$.
 (found in file: \verb+../applications/ns/nssupg.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{free\_surface\_set\_level\_factor@\verb+free_surface_set_level_factor+}
\item\verb+double free_surface_set_level_factor+ {\rm(default=\verb|0.|)}:

This adds a $\Cnst{lf}\bar\eta$ term in the free surface equation
in order to have the total meniscus volume constant. 
 (found in file: \verb+../applications/ns/nssupg.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{friction\_law@\verb+friction_law+}
\item\verb+string friction_law+ {\rm(default=\verb|string("undefined")|)}:

Choose friction law, may be {\tt manning} or {\tt chezy}
 (found in file: \verb+../applications/advdif/stream.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{fs\_debug@\verb+fs_debug+}
\item\verb+int fs_debug+ {\rm(default=\verb|0|)}:

Print some values related to the update of the FS
 (found in file: \verb+../test/spillway/alehook.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{fs\_eq\_factor@\verb+fs_eq_factor+}
\item\verb+double fs_eq_factor+ {\rm(default=\verb|1.|)}:

This factor scales the temporal derivative term
int the free surface equation $w = f \dot p$ equation,
so that for $f=0$ we recover the slip boundary
condition $w=0$. 
 (found in file: \verb+../applications/ns/nssup.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{fs\_eq\_factor@\verb+fs_eq_factor+}
\item\verb+double fs_eq_factor+ {\rm(default=\verb|1.|)}:

$\Cnst{eq}$={\tt fs\_eq\_factor} (see doc for {\tt
free\_surface\_damp} option) is a factor that scales the free
surface ``rigidity''. $\Cnst{eq}=1$ (which is the default) means
no scaling, a zero value means infinitely rigid (as for an
infinite gravity).
 (found in file: \verb+../applications/ns/nssupg.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{fs\_relax@\verb+fs_relax+}
\item\verb+double fs_relax+ {\rm(default=\verb|1.|)}:

Relaxation factor for the update of the free surface position. 
 (found in file: \verb+../test/spillway/alehook.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{fs\_smoothing\_coef@\verb+fs_smoothing_coef+}
\item\verb+double fs_smoothing_coef+ {\rm(default=\verb|0.|)}:

Smoothing factor for the update of the free surface
 position. 
 (found in file: \verb+../test/spillway/alehook.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{function\_name@\verb+function_name+}
\item\verb+string function_name+ {\rm(default=\verb|_default|)}:

Name of extension function
 (found in file: \verb+../src/amplidl.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{g\_dir@\verb+g_dir+}
\item\verb+int g_dir+ {\rm(default=\verb|ndim|)}:

Direction of gravity
 (found in file: \verb+../applications/advdif/gaschem.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{gamma@\verb+gamma+}
\item\verb+double gamma+ {\rm(default=\verb|1.4|)}:

The specific heat ratio. 
 (found in file: \verb+../applications/advective/ffeulerfm2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{gather\_file@\verb+gather_file+}
\item\verb+string gather_file+ {\rm(default=\verb|gather.out|)}:

Print values in this file 
 (found in file: \verb+../applications/advdif/advdif.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{gather\_file@\verb+gather_file+}
\item\verb+string gather_file+ {\rm(default=\verb|"gather.out"|)}:

Print values in this file 
 (found in file: \verb+../applications/ns/ns.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{gather\_length@\verb+gather_length+}
\item\verb+int gather_length+ {\rm(default=\verb|0|)}:

How many gather values will be contributed by this elemset
 (found in file: \verb+../applications/ns/embgath.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{gather\_length@\verb+gather_length+}
\item\verb+int gather_length+ {\rm(default=\verb|0|)}:

How many gather values will be contributed by this elemset
 (found in file: \verb+../src/gatherer.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{gather\_pos@\verb+gather_pos+}
\item\verb+int gather_pos+ {\rm(default=\verb|0|)}:

Position in gather vector
 (found in file: \verb+../applications/ns/embgath.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{gather\_pos@\verb+gather_pos+}
\item\verb+int gather_pos+ {\rm(default=\verb|0|)}:

Position in gather vector
 (found in file: \verb+../src/gatherer.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{geometry@\verb+geometry+}
\item\verb+string geometry+ {\rm(default=\verb|cartesian2d|)}:

Type of element geometry to define Gauss Point data
 (found in file: \verb+../applications/advdif/advdife.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{geometry@\verb+geometry+}
\item\verb+string geometry+ {\rm(default=\verb|cartesian2d|)}:

Type of element geometry to define Gauss Point data
 (found in file: \verb+../applications/advdif/advdifeo.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{geometry@\verb+geometry+}
\item\verb+string geometry+ {\rm(default=\verb|cartesian2d|)}:

Type of element geometry to define Gauss Point data
 (found in file: \verb+../applications/advdif/bccadvfm2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{geometry@\verb+geometry+}
\item\verb+string geometry+ {\rm(default=\verb|cartesian2d|)}:

Type of element geometry to define Gauss Point data
 (found in file: \verb+../applications/advdif/bccadvfm2_old.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{geometry@\verb+geometry+}
\item\verb+string geometry+ {\rm(default=\verb|cartesian2d|)}:

Type of element geometry to define Gauss Point data
 (found in file: \verb+../applications/advdif/bccbubbly.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{geometry@\verb+geometry+}
\item\verb+string geometry+ {\rm(default=\verb|cartesian2d|)}:

Type of element geometry to define Gauss Point data
 (found in file: \verb+../applications/advdif/diff.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{geometry@\verb+geometry+}
\item\verb+string geometry+ {\rm(default=\verb|cartesian1d|)}:

Type of element geometry to define Gauss Point data
 (found in file: \verb+../applications/advdif/genload.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{geometry@\verb+geometry+}
\item\verb+string geometry+ {\rm(default=\verb|cartesian2d|)}:

Type of element geometry to define Gauss Point data
 (found in file: \verb+../applications/advdif/wallswt.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{geometry@\verb+geometry+}
\item\verb+string geometry+ {\rm(default=\verb|cartesian2d|)}:

Type of element geometry to define Gauss Point data
 (found in file: \verb+../applications/advdif/pfcpp_temp.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{geometry@\verb+geometry+}
\item\verb+string geometry+ {\rm(default=\verb|cartesian2d|)}:

Type of element geometry to define Gauss Point data
 (found in file: \verb+../applications/advective/advecfm2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{geometry@\verb+geometry+}
\item\verb+string geometry+ {\rm(default=\verb|cartesian2d|)}:

Type of element geometry to define Gauss Point data
 (found in file: \verb+../applications/advective/advective.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{geometry@\verb+geometry+}
\item\verb+string geometry+ {\rm(default=\verb|cartesian2d|)}:

Type of element geometry to define Gauss Point data
 (found in file: \verb+../applications/advective/bccadvfm2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{geometry@\verb+geometry+}
\item\verb+string geometry+ {\rm(default=\verb|cartesian2d|)}:

Type of element geometry to define Gauss Point data
 (found in file: \verb+../applications/advective/bcconv_adv.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{geometry@\verb+geometry+}
\item\verb+string geometry+ {\rm(default=\verb|cartesian2d|)}:

Type of element geometry to define Gauss Point data
 (found in file: \verb+../applications/laplace/genload.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{geometry@\verb+geometry+}
\item\verb+string geometry+ {\rm(default=\verb|cartesian2d|)}:

Type of element geometry to define Gauss Point data
 (found in file: \verb+../applications/laplace/lapla.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{geometry@\verb+geometry+}
\item\verb+string geometry+ {\rm(default=\verb|cartesian2d|)}:

Type of element geometry to define Gauss Point data
 (found in file: \verb+../applications/ns/adaptor.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{geometry@\verb+geometry+}
\item\verb+string geometry+ {\rm(default=\verb|cartesian2d|)}:

Type of element geometry to define Gauss Point data
 (found in file: \verb+../applications/ns/bccnsfm2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{geometry@\verb+geometry+}
\item\verb+string geometry+ {\rm(default=\verb|cartesian2d|)}:

Type of element geometry to define Gauss Point data
 (found in file: \verb+../applications/ns/bccnstherfm2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{geometry@\verb+geometry+}
\item\verb+string geometry+ {\rm(default=\verb|cartesian2d|)}:

Type of element geometry to define Gauss Point data
 (found in file: \verb+../applications/ns/embgath.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{geometry@\verb+geometry+}
\item\verb+string geometry+ {\rm(default=\verb|quad2hexa|)}:

Type of element geometry to define Gauss Point data
 (found in file: \verb+../applications/ns/embgath.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{geometry@\verb+geometry+}
\item\verb+string geometry+ {\rm(default=\verb|cartesian2d|)}:

Type of element geometry to define Gauss Point data
 (found in file: \verb+../applications/ns/fracstep.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{geometry@\verb+geometry+}
\item\verb+string geometry+ {\rm(default=\verb|cartesian2d|)}:

Type of element geometry to define Gauss Point data
 (found in file: \verb+../applications/ns/fstepfm2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{geometry@\verb+geometry+}
\item\verb+string geometry+ {\rm(default=\verb|cartesian2d|)}:

Type of element geometry to define Gauss Point data
 (found in file: \verb+../applications/ns/genload.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{geometry@\verb+geometry+}
\item\verb+string geometry+ {\rm(default=\verb|cartesian2d|)}:

Type of element geometry to define Gauss Point data
 (found in file: \verb+../applications/ns/nsikeps.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{geometry@\verb+geometry+}
\item\verb+string geometry+ {\rm(default=\verb|cartesian2d|)}:

Type of element geometry to define Gauss Point data
 (found in file: \verb+../applications/ns/nsikepsrot.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{geometry@\verb+geometry+}
\item\verb+string geometry+ {\rm(default=\verb|cartesian2d|)}:

Type of element geometry to define Gauss Point data
 (found in file: \verb+../applications/ns/nsilesther.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{geometry@\verb+geometry+}
\item\verb+string geometry+ {\rm(default=\verb|cartesian2d|)}:

Type of element geometry to define Gauss Point data
 (found in file: \verb+../applications/ns/nsirot.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{geometry@\verb+geometry+}
\item\verb+string geometry+ {\rm(default=\verb|cartesian2d|)}:

Type of element geometry to define Gauss Point data
 (found in file: \verb+../applications/ns/nsitetlesfm2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{geometry@\verb+geometry+}
\item\verb+string geometry+ {\rm(default=\verb|cartesian2d|)}:

Type of element geometry to define Gauss Point data
 (found in file: \verb+../applications/ns/nssupg.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{geometry@\verb+geometry+}
\item\verb+string geometry+ {\rm(default=\verb|cartesian2d|)}:

Type of element geometry to define Gauss Point data
 (found in file: \verb+../applications/ns/wall.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{geometry@\verb+geometry+}
\item\verb+string geometry+ {\rm(default=\verb|cartesian2d|)}:

Type of element geometry to define Gauss Point data
 (found in file: \verb+../applications/ns/wallke.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{geometry@\verb+geometry+}
\item\verb+string geometry+ {\rm(default=\verb|cartesian2d|)}:

Defines the geomtry of the element
 (found in file: \verb+../src/gatherer.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{geometry@\verb+geometry+}
\item\verb+string geometry+ {\rm(default=\verb|"cartesian2d"|)}:

The geometry of the elemset
 (found in file: \verb+../src/interpola.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{geometry@\verb+geometry+}
\item\verb+string geometry+ {\rm(default=\verb|cartesian2d|)}:

Type of element geometry to define Gauss Point data
 (found in file: \verb+../src/surf2vol.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{gmres\_orthogonalization@\verb+gmres_orthogonalization+}
\item\verb+string gmres_orthogonalization+ {\rm(default=\verb|ir_orthog|)}:

Orthogonalization method used in conjunction with GMRES. 
May be  {\tt unmodified\_gram\_schmidt},
\verb+modified_gram_schmidt+ or {\tt ir\_orthog} (default). (Iterative refinement).
See PETSc documentation. 
 (found in file: \verb+../src/iisdmat.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{gravity@\verb+gravity+}
\item\verb+double gravity+ {\rm(default=\verb|1.|)}:

Acceleration of gravity
 (found in file: \verb+../applications/advdif/ffswfm1t.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{gravity@\verb+gravity+}
\item\verb+double gravity+ {\rm(default=\verb|1.|)}:

Acceleration of gravity
 (found in file: \verb+../applications/advdif/ffswfm2t.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{gravity@\verb+gravity+}
\item\verb+double gravity+ {\rm(default=\verb|1.|)}:

Acceleration of gravity
 (found in file: \verb+../applications/advective/ffswfm2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{gravity@\verb+gravity+}
\item\verb+double gravity+ {\rm(default=\verb|1.|)}:

Acceleration of gravity
 (found in file: \verb+../applications/advective/ffswfm2t.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{gravity@\verb+gravity+}
\item\verb+double gravity+ {\rm(default=\verb|1.|)}:

Gravity acceleration. 
 (found in file: \verb+../applications/ns/nssupr.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{h\_min@\verb+h_min+}
\item\verb+double h_min+ {\rm(default=\verb|1e-6|)}:

Threshold value for $h$ while computing turbulence model.
 (found in file: \verb+../applications/advdif/ffswfm1t.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{h\_min@\verb+h_min+}
\item\verb+double h_min+ {\rm(default=\verb|1e-6|)}:

Threshold value for velocity while computing turbulence model.
 (found in file: \verb+../applications/advdif/ffswfm1t.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{h\_min@\verb+h_min+}
\item\verb+double h_min+ {\rm(default=\verb|1e-6|)}:

Threshold value for $h$ while computing turbulence model.
 (found in file: \verb+../applications/advdif/ffswfm2t.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{half\_width@\verb+half_width+}
\item\verb+double half_width+ {\rm(default=\verb|0.5|)}:

The width of the Gaussian, i.e. the time value such that the
relative amplitude falls from the peak value to one half
(#half_width = 0.83255 * sigma#)
 (found in file: \verb+../src/tempfun2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\item\verb+ double[var_len]+ \verb+ hfilm_coeff+ {\rm(default=\verb| no default|)}:
 
Defines coeffcients for the film flux function. May be 
\verb+var_len=0+ (no $\Delta T$ driven load) or
\verb+var_len=ndof*ndof+ a full matrix of relating the flux with
$\Delta !U$. 
  (found in file: \verb+../applications/advdif/linhff.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\item\verb+ double[var_len]+ \verb+ hfilm_source+ {\rm(default=\verb| no default|)}:
 
Defines constant source term for the generic load on
surfaces. May be of length 0 (null load) or \verb+ndof+
which represents a geven load per field. 
  (found in file: \verb+../applications/advdif/linhff.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{hm\_fac@\verb+hm_fac+}
\item\verb+double hm_fac+ {\rm(default=\verb|1.0|)}:

Scales bubble/liquid film exchange
 (found in file: \verb+../applications/advdif/gaschem.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{id\_cn@\verb+id_cn+}
\item\verb+double id_cn+ {\rm(default=\verb|0.|)}:

see doc for \verb+id_fac+
 (found in file: \verb+../applications/advdif/id.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{id\_cn1@\verb+id_cn1+}
\item\verb+double id_cn1+ {\rm(default=\verb|1.|)}:

see doc for \verb+id_fac+
 (found in file: \verb+../applications/advdif/id.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{id\_fac@\verb+id_fac+}
\item\verb+double id_fac+ {\rm(default=\verb|1.|)}:

Residual value is \verb+id_fac*(id_cn * x^n + id_cn1 * x^{n+1})+
 (found in file: \verb+../applications/advdif/id.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{id\_lumped\_cn@\verb+id_lumped_cn+}
\item\verb+double id_lumped_cn+ {\rm(default=\verb|0.|)}:

see doc for \verb+id_fac+
 (found in file: \verb+../applications/advdif/id.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{id\_lumped\_cn1@\verb+id_lumped_cn1+}
\item\verb+double id_lumped_cn1+ {\rm(default=\verb|0.|)}:

see doc for \verb+id_fac+
 (found in file: \verb+../applications/advdif/id.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{identify\_volume\_elements@\verb+identify_volume_elements+}
\item\verb+int identify_volume_elements+ {\rm(default=\verb|0|)}:

Identify automatically the internal volume elements with a face
on the surface
 (found in file: \verb+../applications/ns/embgath.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{identify\_volume\_elements@\verb+identify_volume_elements+}
\item\verb+int identify_volume_elements+ {\rm(default=\verb|0|)}:

Identify automatically the internal volume elements with a face
on the surface
 (found in file: \verb+../src/surf2vol.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{iisdmat\_print\_statistics@\verb+iisdmat_print_statistics+}
\item\verb+int iisdmat_print_statistics+ {\rm(default=\verb|0|)}:

Print dof statistics, number of dofs local and interface in each
processor. 
 (found in file: \verb+../src/iisdcr.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{interface\_full\_preco\_fill@\verb+interface_full_preco_fill+}
\item\verb+double interface_full_preco_fill+ {\rm(default=\verb|1.|)}:

The ILU fill to be used for the \verb+A_II+ problem if the
ILU preconditioning is used
 (found in file: \verb+../src/iisdcr.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{interface\_full\_preco\_maxits@\verb+interface_full_preco_maxits+}
\item\verb+int interface_full_preco_maxits+ {\rm(default=\verb|5|)}:

Number of iters in solving the preconditioning for the 
interface problem when using \verb+use_interface_full_preco+. 
 (found in file: \verb+../src/iisdcr.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{interface\_full\_preco\_pc@\verb+interface_full_preco_pc+}
\item\verb+string interface_full_preco_pc+ {\rm(default=\verb|jacobi|)}:

Defines the preconditioning to be used for the solution
of the diagonal interface problem (not the Schur problem)
 (found in file: \verb+../src/iisdcr.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{interface\_full\_preco\_relax\_factor@\verb+interface_full_preco_relax_factor+}
\item\verb+double interface_full_preco_relax_factor+ {\rm(default=\verb|1.|)}:

The problem on the interface is solved with Richardson method
with few iterations (normally 5). Richardon iteration may not
converge in some cases and then we can help convergence using a
relaxation factor <1
 (found in file: \verb+../src/iisdcr.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{inwt\_stop@\verb+inwt_stop+}
\item\verb+int inwt_stop+ {\rm(default=\verb|0|)}:

If \verb+print_linear_system_and_stop+ is active,
then print system in this Newton iteration 
 (found in file: \verb+../applications/advdif/advdif.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{inwt\_stop@\verb+inwt_stop+}
\item\verb+int inwt_stop+ {\rm(default=\verb|0|)}:

If \verb+print_linear_system_and_stop+ is active,
then print system in this Newton iteration 
 (found in file: \verb+../applications/advdif/advdif_bubbly.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{jacobian\_factor@\verb+jacobian_factor+}
\item\verb+double jacobian_factor+ {\rm(default=\verb|1.|)}:

Scale the jacobian term. 
 (found in file: \verb+../applications/ns/nsitetlesfm2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{kap\_ctff\_val@\verb+kap_ctff_val+}
\item\verb+double kap_ctff_val+ {\rm(default=\verb|1e-20|)}:

Cutoff value for $k$
 (found in file: \verb+../applications/ns/nsikeps.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{kap\_ctff\_val@\verb+kap_ctff_val+}
\item\verb+double kap_ctff_val+ {\rm(default=\verb|1e-20|)}:

Cutoff value for $k$
 (found in file: \verb+../applications/ns/nsikepsrot.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{kappa@\verb+kappa+}
\item\verb+double kappa+ {\rm(default=\verb|1.|)}:

Thermal conductivity
 (found in file: \verb+../applications/ns/nsilesther.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{ket\_min@\verb+ket_min+}
\item\verb+double ket_min+ {\rm(default=\verb|1e-6|)}:

Threshold value for $k$ while computing turbulence model.
 (found in file: \verb+../applications/advdif/ffswfm1t.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{ket\_min@\verb+ket_min+}
\item\verb+double ket_min+ {\rm(default=\verb|1e-6|)}:

Threshold value for $k$ while computing turbulence model.
 (found in file: \verb+../applications/advdif/ffswfm2t.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{lagrange\_diagonal\_factor@\verb+lagrange_diagonal_factor+}
\item\verb+double lagrange_diagonal_factor+ {\rm(default=\verb|0.0|)}:

Using Lagrange multipliers leads to diagonal null terms, which can
cause zero pivots when using direct methods. With this option
a small term is added to the diagonal in order to fix this. The
term is added only in the Jacobian or also in the residual (which
results would be non-consistent). See option
\verb+lagrange_residual_factor+. 
 (found in file: \verb+../applications/advdif/nonlres.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{lagrange\_diagonal\_factor@\verb+lagrange_diagonal_factor+}
\item\verb+double lagrange_diagonal_factor+ {\rm(default=\verb|0.|)}:

Using Lagrange multipliers leads to diagonal null terms, which can
cause zero pivots when using direct methods. With this option
a small term is added to the diagonal in order to fix this. The
term is added only in the Jacobian or also in the residual (which
results would be non-consistent). See option
\verb+lagrange_residual_factor+. 
 (found in file: \verb+../applications/ns/lagmul.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{lagrange\_diagonal\_factor@\verb+lagrange_diagonal_factor+}
\item\verb+double lagrange_diagonal_factor+ {\rm(default=\verb|0.|)}:

Using Lagrange multipliers leads to diagonal null terms, which can
cause zero pivots when using direct methods. With this option
a small term is added to the diagonal in order to fix this. The
term is added only in the Jacobian or also in the residual (which
results would be non-consistent). See option
\verb+lagrange_residual_factor+. 
 (found in file: \verb+../applications/ns/nonlr.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{lagrange\_residual\_factor@\verb+lagrange_residual_factor+}
\item\verb+double lagrange_residual_factor+ {\rm(default=\verb|0.0|)}:

The diagonal term proportional to  \verb+lagrange_diagonal_factor+ 
may be also entered in the residual. If this is so
(\verb+lagrange_residual_factor=1+, then the
method is ``non-consistent'', i.e. the restriction is not exactly
satisfied by the non-linear scheme is exactly Newton-Raphson. If
not (\verb+lagrange_residual_factor=0+) then the restriction is
consistently satisfied but with a non exact Newton-Raphson. 
 (found in file: \verb+../applications/advdif/nonlres.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{lagrange\_residual\_factor@\verb+lagrange_residual_factor+}
\item\verb+double lagrange_residual_factor+ {\rm(default=\verb|0.|)}:

The diagonal term proportional to  \verb+lagrange_diagonal_factor+ 
may be also entered in the residual. If this is so
(\verb+lagrange_residual_factor=1+, then the
method is ``non-consistent'', i.e. the restriction is not exactly
satisfied by the non-linear scheme is exactly Newton-Raphson. If
not (\verb+lagrange_residual_factor=0+) then the restriction is
consistently satisfied but with a non exact Newton-Raphson. 
 (found in file: \verb+../applications/ns/lagmul.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{lagrange\_residual\_factor@\verb+lagrange_residual_factor+}
\item\verb+double lagrange_residual_factor+ {\rm(default=\verb|0.|)}:

The diagonal term proportional to  \verb+lagrange_diagonal_factor+ 
may be also entered in the residual. If this is so
(\verb+lagrange_residual_factor=1+, then the
method is ``non-consistent'', i.e. the restriction is not exactly
satisfied by the non-linear scheme is exactly Newton-Raphson. If
not (\verb+lagrange_residual_factor=0+) then the restriction is
consistently satisfied but with a non exact Newton-Raphson. 
 (found in file: \verb+../applications/ns/nonlr.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{lagrange\_row\_scale\_factor@\verb+lagrange_row_scale_factor+}
\item\verb+double lagrange_row_scale_factor+ {\rm(default=\verb|1.|)}:

Using Lagrange multipliers can lead to bad conditioning, which
causes poor convergence with iterative methods or amplification
of rounding errors. This factor scales the row in the matrix
that correspond to the new equation. 
 (found in file: \verb+../applications/ns/lagmul.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{lagrange\_scale\_factor@\verb+lagrange_scale_factor+}
\item\verb+double lagrange_scale_factor+ {\rm(default=\verb|1.|)}:

Using Lagrange multipliers can lead to bad conditioning, which
causes poor convergence with iterative methods or amplification
of rounding errors. This factor scales the columns in the matrix
that correspond to the lagrange multipliers and can help in
better conditioning the system. 
 (found in file: \verb+../applications/advdif/nonlres.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{lagrange\_scale\_factor@\verb+lagrange_scale_factor+}
\item\verb+double lagrange_scale_factor+ {\rm(default=\verb|1.|)}:

Using Lagrange multipliers can lead to bad conditioning, which
causes poor convergence with iterative methods or amplification
of rounding errors. This factor scales the columns in the matrix
that correspond to the lagrange multipliers and can help in
better conditioning the system. 
 (found in file: \verb+../applications/ns/lagmul.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{lagrange\_scale\_factor@\verb+lagrange_scale_factor+}
\item\verb+double lagrange_scale_factor+ {\rm(default=\verb|1.|)}:

Using Lagrange multipliers can lead to bad conditioning, which
cuases poor convergence with iterative methods or amplification
of rounding errors. This factor scales the columns in the matrix
that correspond to the lagrange multipliers and can help in
better conditioning the system. 
 (found in file: \verb+../applications/ns/nonlr.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{launch\_mesh\_move@\verb+launch_mesh_move+}
\item\verb+int launch_mesh_move+ {\rm(default=\verb|1|)}:

Flag fo launching the `mesh_move' process.
 (found in file: \verb+../test/spillway/alehook.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{layers@\verb+layers+}
\item\verb+int layers+ {\rm(default=\verb|1|)}:

Number of layers in the normal direction.
 (found in file: \verb+../applications/ns/embgath.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{layers@\verb+layers+}
\item\verb+int layers+ {\rm(default=\verb|2|)}:

Number of layers in the normal direction.
 (found in file: \verb+../src/surf2vol.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{local\_solver@\verb+local_solver+}
\item\verb+string local_solver+ {\rm(default=\verb|PETSc|)}:

Chooses the local solver (may be "PETSc" or "SuperLU")
 (found in file: \verb+../src/iisdcr.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{local\_store@\verb+local_store+}
\item\verb+int local_store+ {\rm(default=\verb|0|)}:

Defines a ``locker'' for each element
 (found in file: \verb+../src/readmesh.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{local\_time\_step@\verb+local_time_step+}
\item\verb+int local_time_step+ {\rm(default=\verb|1|)}:

Chooses a time step that varies locally. (Only makes sense
when looking for steady state solutions. 
 (found in file: \verb+../applications/advdif/advdif.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{local\_time\_step@\verb+local_time_step+}
\item\verb+int local_time_step+ {\rm(default=\verb|1|)}:

Chooses a time step that varies locally. (Only makes sense
when looking for steady state solutions. 
 (found in file: \verb+../applications/advdif/advdif_bubbly.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{local\_time\_step@\verb+local_time_step+}
\item\verb+int local_time_step+ {\rm(default=\verb|1|)}:

Chooses a time step that varies locally. (Only makes sense
when looking for steady state solutions. 
 (found in file: \verb+../applications/advective/adv.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\item\verb+ double[2*nalpha]+ \verb+ low_pass_filter+ {\rm(default=\verb| no filter (nalpha=0)|)}:
 
 Enter pair of values \verb+gamma_1 n_1 gamma_2 n_2+ ...
 so that the relaxation time are $\tau_j = 1./gamma_j$ and $n_j$
 is the corresponding order. 
 FIXME:= TO BE DOCUMENTED LATER
  (found in file: \verb+../src/sttfilter.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{lumped\_mass@\verb+lumped_mass+}
\item\verb+int lumped_mass+ {\rm(default=\verb|0|)}:

Use lumped mass (used mainly to avoid oscillations for small time steps).
 (found in file: \verb+../applications/advdif/advdife.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{lumped\_mass@\verb+lumped_mass+}
\item\verb+int lumped_mass+ {\rm(default=\verb|0|)}:

Use lumped mass (used mainly to avoid oscillations for small time steps).
 (found in file: \verb+../applications/advdif/advdifeo.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{lumped\_mass@\verb+lumped_mass+}
\item\verb+int lumped_mass+ {\rm(default=\verb|0|)}:

Use lumped mass (used mainly to avoid oscillations for small time steps).
 (found in file: \verb+../applications/advdif/diff.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{lumped\_mass@\verb+lumped_mass+}
\item\verb+int lumped_mass+ {\rm(default=\verb|0|)}:

Use lumped mass (used mainly to avoid oscillations for small time steps).
 (found in file: \verb+../applications/advdif/pfcpp_temp.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{lumped\_mass@\verb+lumped_mass+}
\item\verb+int lumped_mass+ {\rm(default=\verb|1|)}:

Use lumped mass.
 (found in file: \verb+../applications/advective/advecfm2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{lumped\_mass@\verb+lumped_mass+}
\item\verb+int lumped_mass+ {\rm(default=\verb|1|)}:

Use lumped mass.
 (found in file: \verb+../applications/advective/advective.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{lumped\_wallke@\verb+lumped_wallke+}
\item\verb+int lumped_wallke+ {\rm(default=\verb|0|)}:

Use lumped mass matric for the wall element contribution. Avoids
oscillations due to ``reactive type'' wall contributions. 
 (found in file: \verb+../applications/ns/wallke.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{mat\_new\_nonzero\_allocation\_err@\verb+mat_new_nonzero_allocation_err+}
\item\verb+int mat_new_nonzero_allocation_err+ {\rm(default=\verb|1|)}:

Pass option to underlying PETSc matrix. Gives an error if a new
element is added
 (found in file: \verb+../src/petscmat.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{max\_partgraph\_vertices@\verb+max_partgraph_vertices+}
\item\verb+int max_partgraph_vertices+ {\rm(default=\verb|INF|)}:

Maximum number of vertices admissible while computing the
partitioning graph.
 (found in file: \verb+../src/readmesh.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{max\_partgraph\_vertices\_proc@\verb+max_partgraph_vertices_proc+}
\item\verb+int max_partgraph_vertices_proc+ {\rm(default=\verb|INF|)}:

The maximum number of vertices in the coarse mesh for
sub-partitioning the dof graph in the IISD matrix. 
 (found in file: \verb+../src/iisdcr.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{maxits@\verb+maxits+}
\item\verb+int maxits+ {\rm(default=\verb|150|)}:

Maximum iterations when solving a consistent matrix
 (found in file: \verb+../applications/advdif/advdif.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{maxits@\verb+maxits+}
\item\verb+int maxits+ {\rm(default=\verb|150|)}:

Maximum iterations when solving a consistent matrix
 (found in file: \verb+../applications/advdif/advdif_bubbly.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{maxits@\verb+maxits+}
\item\verb+int maxits+ {\rm(default=\verb|150|)}:

Maximum iterations when solving a consistent matrix
 (found in file: \verb+../applications/advective/adv.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{maxits@\verb+maxits+}
\item\verb+int maxits+ {\rm(default=\verb|Krylov_dim|)}:

Maximum iteration number in solving the monolithic linear
system (Newton linear subiteration).
 (found in file: \verb+../src/iisdmat.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{measure\_performance@\verb+measure_performance+}
\item\verb+int measure_performance+ {\rm(default=\verb|0|)}:

Measure performance of the \verb+comp_mat_res+ jobinfo. 
 (found in file: \verb+../applications/advdif/advdif.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{measure\_performance@\verb+measure_performance+}
\item\verb+int measure_performance+ {\rm(default=\verb|0|)}:

Measure performance of the \verb+comp_mat_res+ jobinfo. 
 (found in file: \verb+../applications/advdif/advdif_bubbly.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{measure\_performance@\verb+measure_performance+}
\item\verb+int measure_performance+ {\rm(default=\verb|0|)}:

Measure performance of the \verb+comp_mat_res+ jobinfo. 
 (found in file: \verb+../applications/advective/adv.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{measure\_performance@\verb+measure_performance+}
\item\verb+int measure_performance+ {\rm(default=\verb|0|)}:

Measure performance of the 'comp\_mat\_res' jobinfo. 
 (found in file: \verb+../applications/ns/ns.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{measure\_performance\_weight@\verb+measure_performance_weight+}
\item\verb+double measure_performance_weight+ {\rm(default=\verb|1.|)}:

Weight for computing performance
 (found in file: \verb+../src/measperf.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\item\verb+ double[ndim]+ \verb+ moment_center+ {\rm(default=\verb| null vector|)}:
 Center of moments.  (found in file: \verb+../applications/ns/embgath.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\item\verb+ double[ndim]+ \verb+ moment_center+ {\rm(default=\verb| null vector|)}:
 Center of moments.  (found in file: \verb+../applications/ns/nsgath.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{ndim@\verb+ndim+}
\item\verb+int ndim+ {\rm(default=\verb|none|)}:

Dimension of the embedding space
 (found in file: \verb+../applications/advdif/advdfgth.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{ndim@\verb+ndim+}
\item\verb+int ndim+ {\rm(default=\verb|0|)}:

Dimension of the problem
 (found in file: \verb+../applications/advdif/gaschem.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{ndim@\verb+ndim+}
\item\verb+int ndim+ {\rm(default=\verb|none|)}:

Dimension of the embedding space
 (found in file: \verb+../applications/ns/embgath.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{ndim@\verb+ndim+}
\item\verb+int ndim+ {\rm(default=\verb|none|)}:

Dimension of the embedding space
 (found in file: \verb+../applications/ns/embgath.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{ndim@\verb+ndim+}
\item\verb+int ndim+ {\rm(default=\verb|3|)}:

Dimension of the problem.
 (found in file: \verb+../applications/ns/ns.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{ndim@\verb+ndim+}
\item\verb+int ndim+ {\rm(default=\verb|none|)}:

Dimension of the embedding space
 (found in file: \verb+../applications/ns/nsgath.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{ndim@\verb+ndim+}
\item\verb+int ndim+ {\rm(default=\verb|none|)}:

Dimension of the embedding space
 (found in file: \verb+../applications/ns/nsgath.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{ndim@\verb+ndim+}
\item\verb+int ndim+ {\rm(default=\verb|0|)}:

Dimension of problem
 (found in file: \verb+../applications/ns/nssupr.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{ndim@\verb+ndim+}
\item\verb+int ndim+ {\rm(default=\verb|0|)}:

The number of spatial dimensions
 (found in file: \verb+../applications/ns/nullvort.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{ndim@\verb+ndim+}
\item\verb+int ndim+ {\rm(default=\verb|none|)}:

Dimension of the embedding space
 (found in file: \verb+../src/gatherer.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{ndim@\verb+ndim+}
\item\verb+int ndim+ {\rm(default=\verb|0|)}:

The space dimension
 (found in file: \verb+../src/interpola.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{ndim@\verb+ndim+}
\item\verb+int ndim+ {\rm(default=\verb|0|)}:

The space dimension
 (found in file: \verb+../src/interpola.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{ndimel@\verb+ndimel+}
\item\verb+int ndimel+ {\rm(default=\verb|ndim-1|)}:

Dimenson of the element
 (found in file: \verb+../applications/advdif/advdfgth.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{ndimel@\verb+ndimel+}
\item\verb+int ndimel+ {\rm(default=\verb|ndim-1|)}:

The dimension of the element 
 (found in file: \verb+../applications/advdif/genload.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{ndimel@\verb+ndimel+}
\item\verb+int ndimel+ {\rm(default=\verb|ndim-1|)}:

Dimenson of the element
 (found in file: \verb+../applications/ns/nsgath.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{ndimel@\verb+ndimel+}
\item\verb+int ndimel+ {\rm(default=\verb|ndim-1|)}:

Dimenson of the element
 (found in file: \verb+../applications/ns/nsgath.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{ndimel@\verb+ndimel+}
\item\verb+int ndimel+ {\rm(default=\verb|ndim-1|)}:

Dimenson of the element
 (found in file: \verb+../src/gatherer.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{ndimelf@\verb+ndimelf+}
\item\verb+int ndimelf+ {\rm(default=\verb|ndimel-1|)}:

Dimension of bcconv element
 (found in file: \verb+../applications/advdif/bccadvfm2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{nel\_surf@\verb+nel_surf+}
\item\verb+int nel_surf+ {\rm(default=\verb|0|)}:

The number of nodes per skin panel. 
 (found in file: \verb+../applications/ns/nullvort.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\item\verb+ vector<double>+ \verb+ newton_relaxation_factor+ {\rm(default=\verb| (none)|)}:

Relaxation parameter for Newton iteration. Several
values may be entered in the form
%
\begin{verbatim} 
newton_relaxation_factor w1 n1 w2 n2 .... wn
\end{verbatim}
%
that means: Take relaxation factor \verb+w1+
for the first \verb+n1+ steps, \verb+w2+ for the following \verb+n2+ steps
and so on until \verb+w_{n-1}+. \verb+wn+ is taken for all subsequent 
steps. Normally one takes a conservative (said 0.5) relaxation
factor for the first steps and then let full Newton (i.e. \verb+w=1+)
for the rest. For instance, the line  
%
\begin{verbatim} 
newton_relaxation_factor 0.5 3 1.
\end{verbatim}
%
means: take $w=0.5$ for the first 3 steps, and then use $w=1$. 
 (found in file: \verb+../applications/ns/ns.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{nfile@\verb+nfile+}
\item\verb+int nfile+ {\rm(default=\verb|1|)}:

Sets the number of files in the ``rotary save'' mechanism. 
(see \ref{sec:rotary_save})
 (found in file: \verb+../applications/advdif/advdif.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{nfile@\verb+nfile+}
\item\verb+int nfile+ {\rm(default=\verb|1|)}:

Sets the number of files in the ``rotary save'' mechanism. 
(see \ref{sec:rotary_save})
 (found in file: \verb+../applications/advdif/advdif_bubbly.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{nfile@\verb+nfile+}
\item\verb+int nfile+ {\rm(default=\verb|1|)}:

Sets the number of files in the ``rotary save'' mechanism. 
(see \ref{sec:rotary_save})
 (found in file: \verb+../applications/advective/adv.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{nfile@\verb+nfile+}
\item\verb+int nfile+ {\rm(default=\verb|1|)}:

Sets the number of files in the ``rotary save'' mechanism. 
(see \ref{sec:rotary_save})
 (found in file: \verb+../applications/ns/ns.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{nfilt@\verb+nfilt+}
\item\verb+int nfilt+ {\rm(default=\verb|1|)}:

Number of times the filter is applied
 (found in file: \verb+../test/spillway/alehook.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{ngather@\verb+ngather+}
\item\verb+int ngather+ {\rm(default=\verb|0|)}:

Number of ``gathered'' quantities.
 (found in file: \verb+../applications/advdif/advdif.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{ngather@\verb+ngather+}
\item\verb+int ngather+ {\rm(default=\verb|0|)}:

Number of ``gathered'' quantities.
 (found in file: \verb+../applications/ns/ns.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{nnwt@\verb+nnwt+}
\item\verb+int nnwt+ {\rm(default=\verb|3|)}:

Number of iterations in the Newton loop. (
for the implicit method. 
 (found in file: \verb+../applications/advdif/advdif.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{nnwt@\verb+nnwt+}
\item\verb+int nnwt+ {\rm(default=\verb|3|)}:

Number of iterations in the Newton loop. (
for the implicit method. 
 (found in file: \verb+../applications/advdif/advdif_bubbly.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{nnwt@\verb+nnwt+}
\item\verb+int nnwt+ {\rm(default=\verb|1|)}:

Number of inner iterations for the global non-linear
Newton  problem. 
 (found in file: \verb+../applications/ns/ns.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{nnwt\_liq@\verb+nnwt_liq+}
\item\verb+int nnwt_liq+ {\rm(default=\verb|3|)}:

Flag if steady solution or not (uses Dt=inf). If \verb+steady+
 (found in file: \verb+../applications/advdif/advdif_bubbly.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{non\_inertial\_frame@\verb+non_inertial_frame+}
\item\verb+int non_inertial_frame+ {\rm(default=\verb|0|)}:

The system is in a non-inertial frame. Get linear and rotational
velocities and accelerations from fictitious nodes. The
 (found in file: \verb+../applications/ns/nsikepsrot.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{non\_inertial\_frame\_reverse\_sign@\verb+non_inertial_frame_reverse_sign+}
\item\verb+int non_inertial_frame_reverse_sign+ {\rm(default=\verb|0|)}:

Reverse sign so that the fictitious node velocities and
accelerations represent the movement of the container with
respect to an instantaneous inertial frame. 
 (found in file: \verb+../applications/ns/nsikepsrot.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{normal\_1d@\verb+normal_1d+}
\item\verb+double normal_1d+ {\rm(default=\verb|0.|)}:

Normal (only makes sense in 1D). 
 (found in file: \verb+../applications/advdif/bccadvfm2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{npg@\verb+npg+}
\item\verb+int npg+ {\rm(default=\verb|0|)}:

Number of Gauss points.
 (found in file: \verb+../applications/ns/adaptor.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{npg@\verb+npg+}
\item\verb+int npg+ {\rm(default=\verb|none|)}:

Number of Gauss points.
 (found in file: \verb+../applications/ns/embgath.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{npg@\verb+npg+}
\item\verb+int npg+ {\rm(default=\verb|none|)}:

Number of Gauss points.
 (found in file: \verb+../applications/ns/genload.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{npg@\verb+npg+}
\item\verb+int npg+ {\rm(default=\verb|none|)}:

Number of Gauss points.
 (found in file: \verb+../applications/ns/nsikeps.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{npg@\verb+npg+}
\item\verb+int npg+ {\rm(default=\verb|none|)}:

Number of Gauss points.
 (found in file: \verb+../applications/ns/nsikepsrot.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{npg@\verb+npg+}
\item\verb+int npg+ {\rm(default=\verb|none|)}:

Number of Gauss points.
 (found in file: \verb+../applications/ns/nsilesther.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{npg@\verb+npg+}
\item\verb+int npg+ {\rm(default=\verb|none|)}:

Number of Gauss points.
 (found in file: \verb+../applications/ns/nsirot.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{npg@\verb+npg+}
\item\verb+int npg+ {\rm(default=\verb|none|)}:

Number of Gauss points.
 (found in file: \verb+../applications/ns/nsitetlesfm2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{npg@\verb+npg+}
\item\verb+int npg+ {\rm(default=\verb|none|)}:

Number of Gauss points.
 (found in file: \verb+../applications/ns/nssupg.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{npg@\verb+npg+}
\item\verb+int npg+ {\rm(default=\verb|none|)}:

Number of Gauss points.
 (found in file: \verb+../src/gatherer.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{npg@\verb+npg+}
\item\verb+int npg+ {\rm(default=\verb|none|)}:

Number of Gauss points.
 (found in file: \verb+../src/surf2vol.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{nrec@\verb+nrec+}
\item\verb+int nrec+ {\rm(default=\verb|1000000|)}:

Sets the number of states saved in a given file
in the ``rotary save'' mechanism (see \ref{sec:rotary_save}
 (found in file: \verb+../applications/advdif/advdif.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{nrec@\verb+nrec+}
\item\verb+int nrec+ {\rm(default=\verb|1000000|)}:

Sets the number of states saved in a given file
in the ``rotary save'' mechanism (see \ref{sec:rotary_save}
 (found in file: \verb+../applications/advdif/advdif_bubbly.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{nrec@\verb+nrec+}
\item\verb+int nrec+ {\rm(default=\verb|1000000|)}:

Sets the number of states saved in a given file
in the ``rotary save'' mechanism (see \ref{sec:rotary_save}
 (found in file: \verb+../applications/advective/adv.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{nrec@\verb+nrec+}
\item\verb+int nrec+ {\rm(default=\verb|1000000|)}:

Sets the number of states saved in a given file
in the ``rotary save'' mechanism (see \ref{sec:rotary_save}
 (found in file: \verb+../applications/ns/ns.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{ns\_id\_cn@\verb+ns_id_cn+}
\item\verb+double ns_id_cn+ {\rm(default=\verb|0.|)}:

see doc for \verb+ns_id_fac+
 (found in file: \verb+../applications/ns/nsid.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{ns\_id\_cn1@\verb+ns_id_cn1+}
\item\verb+double ns_id_cn1+ {\rm(default=\verb|1.|)}:

see doc for \verb+ns_id_fac+
 (found in file: \verb+../applications/ns/nsid.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{ns\_id\_fac@\verb+ns_id_fac+}
\item\verb+double ns_id_fac+ {\rm(default=\verb|1.|)}:

Residual value is
#ns_id_fac*(ns_id_cn *(x^n-x_ref) + ns_id_cn1 * (x^{n+1}-x_ref))#
 (found in file: \verb+../applications/ns/nsid.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{ns\_id\_lumped\_cn@\verb+ns_id_lumped_cn+}
\item\verb+double ns_id_lumped_cn+ {\rm(default=\verb|0.|)}:

see doc for \verb+ns_id_fac+
 (found in file: \verb+../applications/ns/nsid.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{ns\_id\_lumped\_cn1@\verb+ns_id_lumped_cn1+}
\item\verb+double ns_id_lumped_cn1+ {\rm(default=\verb|0.|)}:

see doc for \verb+ns_id_fac+
 (found in file: \verb+../applications/ns/nsid.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{nsave@\verb+nsave+}
\item\verb+int nsave+ {\rm(default=\verb|10|)}:

Save state vector frequency (in steps)
 (found in file: \verb+../applications/advdif/advdif.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{nsave@\verb+nsave+}
\item\verb+int nsave+ {\rm(default=\verb|10|)}:

Save state vector frequency (in steps)
 (found in file: \verb+../applications/advdif/advdif_bubbly.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{nsave@\verb+nsave+}
\item\verb+int nsave+ {\rm(default=\verb|10|)}:

Save state vector frequency (in steps)
 (found in file: \verb+../applications/advective/adv.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{nsave@\verb+nsave+}
\item\verb+int nsave+ {\rm(default=\verb|10|)}:

Sets the save frequency in iterations 
 (found in file: \verb+../applications/ns/ns.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{nsaverot@\verb+nsaverot+}
\item\verb+int nsaverot+ {\rm(default=\verb|100|)}:

Save state vector frequency with the ``rotary save''
mechanism. (see \ref{sec:rotary_save})
 (found in file: \verb+../applications/advdif/advdif.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{nsaverot@\verb+nsaverot+}
\item\verb+int nsaverot+ {\rm(default=\verb|100|)}:

Save state vector frequency with the ``rotary save''
mechanism. (see \ref{sec:rotary_save})
 (found in file: \verb+../applications/advdif/advdif_bubbly.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{nsaverot@\verb+nsaverot+}
\item\verb+int nsaverot+ {\rm(default=\verb|100|)}:

Save state vector frequency with the ``rotary save''
mechanism. (see \ref{sec:rotary_save})
 (found in file: \verb+../applications/advective/adv.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{nsaverot@\verb+nsaverot+}
\item\verb+int nsaverot+ {\rm(default=\verb|100|)}:

Sets the frequency save for the ``rotary save'' mechanism. 
\label{sec:rotary_save}
Sometimes it is interesting to save the state vector with a certain
frequency in a ``append'' manner, i.e. appending the state vector at
the end of the file. However, this posses the danger of storing too
much amount of data if the user performs a very long run. The ``rotary
save'' mechanism allows writing only a certain amount of the recent
states. The mechanism basically saves the state vector each
\verb+nsaverot+ steps appending to the a file. The name of the file is
contructed from a pattern set by the user via the
\verb+save_file_pattern+ entry, by replacing \verb+%d+ 
by \verb+0+ ``\`a la'' \verb+printf()+. For instance, if
\verb+save_file_pattern+ i set to \verb+file%d.out+ 
then the state vectors are appended to \verb+file0.out+.  When the
number of written states reach the \verb+nrec+ count, the file is
reset to 0, and the saving continues from the start of the
file. However, if \verb+nfile+ is greater than one, then the state
vector are continued to be stored in file \verb+file1.out+ and so
on. When the number of files \verb+nfile+ is reached, the saving
continues in file '0'.

More precisely, the saving mechanism is described by the following
pseudo-code:

% %\begin{latexonly}
% % algorithmic environment is not correctly processed by Latex2HTML
% \begin{algorithmic}
% \STATE read state vector from \verb+initial_state+ file into $x^0$, $n\gets 0$.
% \FOR{$i$=0 to {\tt nstep}}
%   \STATE advance $x^n$ to $x^{n+1}$.
%   \IF{$n$ \% {\tt nsaverot} == 0}
%     \STATE $j \gets n$/{\tt nsaverot}
%     \STATE $k \gets j$ \% {\tt nrec}
%     \STATE $l \gets j$/{\tt nrec}
%     \IF{$k=0$}\STATE rewind file $l$ \ENDIF
%     \STATE append state vector to file $l$
%   \ENDIF
% \ENDFOR
% \end{algorithmic}
% %\end{latexonly}
%%%<>%%%<>%%%<>%%%<>%%%<>%%%<>%%%<>%%%<>%%%<>%%%<>%%%<>%%%<>%%%<> 
% algorithmic environment is not correctly processed by Latex2HTML
% \begin{htmlonly}
\begin{verbatim}
Read state vector from `initial_state' file into x^0, n=0;
for (i=0; i<nstep; i++) {
   advance x^n to x^{n+1};
   if (n % nsaverot == 0) {
           j <- n/nsaverot;
           k <- j % nrec;
           l <- j / nrec;
           if (k==0) { rewind file l; }
           append state vector to file l;
   }
}
\end{verbatim}
% \end{htmlonly}
 (found in file: \verb+../applications/ns/ns.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{nsc@\verb+nsc+}
\item\verb+int nsc+ {\rm(default=\verb|1|)}:

If Navier-Stokes compressible
 (found in file: \verb+../applications/ns/nsgath.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{nsome@\verb+nsome+}
\item\verb+int nsome+ {\rm(default=\verb|10000|)}:

Sets the save frequency in iterations for the ``print some''
mechanism. (see doc in the Navier-Stokes module)
 (found in file: \verb+../applications/advdif/advdif.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{nsome@\verb+nsome+}
\item\verb+int nsome+ {\rm(default=\verb|10000|)}:

Sets the save frequency in iterations for the ``print some''
mechanism. (see doc in the Navier-Stokes module)
 (found in file: \verb+../applications/advdif/advdif_bubbly.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{nsome@\verb+nsome+}
\item\verb+int nsome+ {\rm(default=\verb|10000|)}:

Sets the save frequency in iterations for the ``print some''
mechanism. 
\label{sec:print_some}
The ``print some'' mechanism allows the user to store the variables of
some set of nodes with some frequency. The nodes are entered in a
separate file whose name is given by a \verb+print_some_file+ entry in
the general options, one node per line. The entry \verb+nsome+
indicates the frequency (in steps) at which the data is saved and
\verb+save_file_some+ the name of the file to save in. 
 (found in file: \verb+../applications/ns/ns.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{nstep@\verb+nstep+}
\item\verb+int nstep+ {\rm(default=\verb|10000|)}:

The number of time steps. 
 (found in file: \verb+../applications/advdif/advdif.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{nstep@\verb+nstep+}
\item\verb+int nstep+ {\rm(default=\verb|10000|)}:

The number of time steps. 
 (found in file: \verb+../applications/advdif/advdif_bubbly.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{nstep@\verb+nstep+}
\item\verb+int nstep+ {\rm(default=\verb|10000|)}:

The number of time steps. 
 (found in file: \verb+../applications/advective/adv.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{nstep@\verb+nstep+}
\item\verb+int nstep+ {\rm(default=\verb|10000|)}:

The number of time steps. 
 (found in file: \verb+../applications/ns/ns.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{nstep\_cpu\_stat@\verb+nstep_cpu_stat+}
\item\verb+int nstep_cpu_stat+ {\rm(default=\verb|10|)}:

Output CPU time statistics for frequency in time steps. 
 (found in file: \verb+../applications/advdif/advdif.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{nstep\_cpu\_stat@\verb+nstep_cpu_stat+}
\item\verb+int nstep_cpu_stat+ {\rm(default=\verb|10|)}:

Output CPU time statistics for frequency in time steps. 
 (found in file: \verb+../applications/advdif/advdif_bubbly.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{nstep\_cpu\_stat@\verb+nstep_cpu_stat+}
\item\verb+int nstep_cpu_stat+ {\rm(default=\verb|10|)}:

Output CPU time statistics for frequency in time steps. 
 (found in file: \verb+../applications/advective/adv.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{nu\_t@\verb+nu_t+}
\item\verb+double nu_t+ {\rm(default=\verb|0.|)}:

Turbulent viscosity
 (found in file: \verb+../applications/advdif/gaschem.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{omega@\verb+omega+}
\item\verb+double omega+ {\rm(default=\verb|0.|)}:

Frequency of oscillating local source. 
 (found in file: \verb+../applications/advdif/smoke.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{omega\_newton@\verb+omega_newton+}
\item\verb+double omega_newton+ {\rm(default=\verb|1.|)}:

Relaxation factor for the Newton iteration
 (found in file: \verb+../applications/advdif/advdif.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{omega\_newton@\verb+omega_newton+}
\item\verb+double omega_newton+ {\rm(default=\verb|1.|)}:

Relaxation factor for the Newton iteration
 (found in file: \verb+../applications/advdif/advdif_bubbly.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{p\_thrsh@\verb+p_thrsh+}
\item\verb+double p_thrsh+ {\rm(default=\verb|0.|)}:

Threshold value for pressure. See doc for rho_thrsh.
 (found in file: \verb+../applications/advdif/gasflow.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{part\_include\_fic@\verb+part_include_fic+}
\item\verb+int part_include_fic+ {\rm(default=\verb|1|)}:

Do partitioning including fictitious nodes
 (found in file: \verb+../applications/ns/nsid.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{part\_include\_fic@\verb+part_include_fic+}
\item\verb+int part_include_fic+ {\rm(default=\verb|1|)}:

Do partitioning including fictitious nodes
 (found in file: \verb+../applications/ns/nsikepsrot.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{partitioning\_method@\verb+partitioning_method+}
\item\verb+string partitioning_method+ {\rm(default=\verb|metis|)}:

Set partitioning method. May be set to \verb+metis+,
\verb+hitchhiking+, \verb+nearest_neighbor+ or \verb+random+.
 (found in file: \verb+../src/readmesh.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{pc\_lu\_fill@\verb+pc_lu_fill+}
\item\verb+double pc_lu_fill+ {\rm(default=\verb|5.|)}:

PETSc parameter related to the efficiency in growing
  the factored profile.
 (found in file: \verb+../src/iisdcr.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{peak@\verb+peak+}
\item\verb+double peak+ {\rm(default=\verb|base+1.|)}:

The absolute peak value of the Gaussian
 (found in file: \verb+../src/tempfun2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{phieq@\verb+phieq+}
\item\verb+double phieq+ {\rm(default=\verb|0.|)}:

Equilibrium value (#+phieq#, and #-phieq#). 
 (found in file: \verb+../applications/advdif/smoke.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{preco\_side@\verb+preco_side+}
\item\verb+string preco_side+ {\rm(default=\verb|<ksp-dependent>|)}:

Uses right or left preconditioning. Default is \verb+right+ for
GMRES. 
 (found in file: \verb+../src/iisdmat.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{preco\_type@\verb+preco_type+}
\item\verb+string preco_type+ {\rm(default=\verb|jacobi|)}:

Chooses the preconditioning operator. 
 (found in file: \verb+../applications/advdif/advdif.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{preco\_type@\verb+preco_type+}
\item\verb+string preco_type+ {\rm(default=\verb|jacobi|)}:

Chooses the preconditioning operator. 
 (found in file: \verb+../applications/advdif/advdif_bubbly.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{preco\_type@\verb+preco_type+}
\item\verb+string preco_type+ {\rm(default=\verb|jacobi|)}:

Chooses the preconditioning operator. 
 (found in file: \verb+../src/iisdmat.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{pressure\_comp\_mask@\verb+pressure_comp_mask+}
\item\verb+double pressure_comp_mask+ {\rm(default=\verb|1.|)}:

Mask for pressure (normal) component of stress tensor 
 (found in file: \verb+../applications/ns/embgath.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{pressure\_control\_coef@\verb+pressure_control_coef+}
\item\verb+double pressure_control_coef+ {\rm(default=\verb|0.|)}:

Add pressure controlling term. 
 (found in file: \verb+../applications/ns/nsitetlesfm2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{print\_Schur\_matrix@\verb+print_Schur_matrix+}
\item\verb+int print_Schur_matrix+ {\rm(default=\verb|0|)}:

Print the Schur matrix (don't try this for big problems).
 (found in file: \verb+../src/iisdcr.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{print\_dofmap\_id@\verb+print_dofmap_id+}
\item\verb+int print_dofmap_id+ {\rm(default=\verb|0|)}:

Prints the dofmap \verb+idmap+ object. 
 (found in file: \verb+../src/readmesh.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{print\_fsm\_transition\_info@\verb+print_fsm_transition_info+}
\item\verb+int print_fsm_transition_info+ {\rm(default=\verb|0|)}:

Print Finite State Machine transitions for PFPETScMat matrices.
1: print inmediately, 2: gather events (non immediate printing). 
 (found in file: \verb+../src/iisdmat.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{print\_interface\_full\_preco\_conv@\verb+print_interface_full_preco_conv+}
\item\verb+int print_interface_full_preco_conv+ {\rm(default=\verb|0|)}:

Flags whether or not print the convergence when solving the
preconditioning for the interface problem when using
\verb+use_interface_full_preco+.
 (found in file: \verb+../src/iisdcr.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{print\_internal\_loop\_conv@\verb+print_internal_loop_conv+}
\item\verb+int print_internal_loop_conv+ {\rm(default=\verb|0|)}:

Prints the convergence history when solving a consistent matrix
 (found in file: \verb+../applications/advdif/advdif.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{print\_internal\_loop\_conv@\verb+print_internal_loop_conv+}
\item\verb+int print_internal_loop_conv+ {\rm(default=\verb|0|)}:

Prints the convergence history when solving a consistent matrix
 (found in file: \verb+../applications/advdif/advdif_bubbly.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{print\_internal\_loop\_conv@\verb+print_internal_loop_conv+}
\item\verb+int print_internal_loop_conv+ {\rm(default=\verb|0|)}:

Prints the convergence history when solving a consistent matrix
 (found in file: \verb+../applications/advective/adv.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{print\_internal\_loop\_conv@\verb+print_internal_loop_conv+}
\item\verb+int print_internal_loop_conv+ {\rm(default=\verb|0|)}:

Prints convergence in the solution of the GMRES iteration. 
 (found in file: \verb+../src/iisdmat.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{print\_linear\_system\_and\_stop@\verb+print_linear_system_and_stop+}
\item\verb+int print_linear_system_and_stop+ {\rm(default=\verb|0|)}:

After computing the linear system prints Jacobian and
right hand side and stops.. 
 (found in file: \verb+../applications/advdif/advdif.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{print\_linear\_system\_and\_stop@\verb+print_linear_system_and_stop+}
\item\verb+int print_linear_system_and_stop+ {\rm(default=\verb|0|)}:

After computing the linear system prints Jacobian and
right hand side and stops.. 
 (found in file: \verb+../applications/advdif/advdif_bubbly.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{print\_linear\_system\_and\_stop@\verb+print_linear_system_and_stop+}
\item\verb+int print_linear_system_and_stop+ {\rm(default=\verb|0|)}:

After computing the linear system prints Jacobian and
right hand side and stops.. 
 (found in file: \verb+../applications/advective/adv.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{print\_linear\_system\_and\_stop@\verb+print_linear_system_and_stop+}
\item\verb+int print_linear_system_and_stop+ {\rm(default=\verb|0|)}:

After computing the linear system solves it and prints Jacobian,
right hand side and solution vector, and stops. 
 (found in file: \verb+../applications/ns/ns.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{print\_local\_chunk\_size@\verb+print_local_chunk_size+}
\item\verb+int print_local_chunk_size+ {\rm(default=\verb|0|)}:

Print the local chunk size used for each elemset in each
processor for each chunk. 
 (found in file: \verb+../src/elemset.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{print\_partitioning\_statistics@\verb+print_partitioning_statistics+}
\item\verb+int print_partitioning_statistics+ {\rm(default=\verb|0|)}:

Print graph statistics
 (found in file: \verb+../src/readmesh.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{print\_residual@\verb+print_residual+}
\item\verb+int print_residual+ {\rm(default=\verb|0|)}:

Print the residual each \verb+nsave+ steps. 
 (found in file: \verb+../applications/advdif/advdif.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{print\_residual@\verb+print_residual+}
\item\verb+int print_residual+ {\rm(default=\verb|0|)}:

Print the residual each \verb+nsave+ steps. 
 (found in file: \verb+../applications/advdif/advdif_bubbly.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{print\_residual@\verb+print_residual+}
\item\verb+int print_residual+ {\rm(default=\verb|0|)}:

Print the residual each \verb+nsave+ steps. 
 (found in file: \verb+../applications/ns/ns.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{print\_some\_file@\verb+print_some_file+}
\item\verb+string print_some_file+ {\rm(default=\verb||)}:

Name of file where to read the nodes for the ``print some'' 
feature. 
 (found in file: \verb+../applications/advdif/advdif.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{print\_some\_file@\verb+print_some_file+}
\item\verb+string print_some_file+ {\rm(default=\verb||)}:

Name of file where to read the nodes for the ``print some'' 
feature. 
 (found in file: \verb+../applications/advdif/advdif_bubbly.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{print\_some\_file@\verb+print_some_file+}
\item\verb+string print_some_file+ {\rm(default=\verb||)}:

Name of file where to read the nodes for the ``print some'' 
feature. 
 (found in file: \verb+../applications/ns/ns.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{pspg\_advection\_factor@\verb+pspg_advection_factor+}
\item\verb+double pspg_advection_factor+ {\rm(default=\verb|1.|)}:

Scales the term proportional to $h/u$ in the pspg stabilization term
 (found in file: \verb+../applications/ns/nsikeps.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{pspg\_advection\_factor@\verb+pspg_advection_factor+}
\item\verb+double pspg_advection_factor+ {\rm(default=\verb|1.|)}:

Scales the term proportional to $h/u$ in the pspg stabilization term
 (found in file: \verb+../applications/ns/nsikepsrot.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{pspg\_advection\_factor@\verb+pspg_advection_factor+}
\item\verb+double pspg_advection_factor+ {\rm(default=\verb|1.|)}:

Scales the term proportional to $h/u$ in the pspg stabilization term
 (found in file: \verb+../applications/ns/nsirot.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{pspg\_factor@\verb+pspg_factor+}
\item\verb+double pspg_factor+ {\rm(default=\verb|1.|)}:

Scales the PSPG stabilization term 
 (found in file: \verb+../applications/ns/nsikeps.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{pspg\_factor@\verb+pspg_factor+}
\item\verb+double pspg_factor+ {\rm(default=\verb|1.|)}:

Scales the PSPG stabilization term 
 (found in file: \verb+../applications/ns/nsikepsrot.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{pspg\_factor@\verb+pspg_factor+}
\item\verb+double pspg_factor+ {\rm(default=\verb|1.|)}:

Scales the PSPG stabilization term
 (found in file: \verb+../applications/ns/nsirot.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{rain@\verb+rain+}
\item\verb+double rain+ {\rm(default=\verb|0.|)}:

Constant rain
 (found in file: \verb+../applications/advdif/aquifer.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\item\verb+ double[var_len]+ \verb+ reactive_jacobians+ {\rm(default=\verb| all zero|)}:
 
Jacobian of reactive fluxes, i.e. 
\[ 
   R_{\mu\nu} = \dep {G_\mu}{U_\nu}
\]
%
(see documentation for the \verb+source_term+ option). 
The full jacobian has \verb+ndof*ndof+ components, but in many
cases the Jacobian is not full. The following cases are
considered. (See the description for the \verb+advective_jacobians+
entry). 
%
\begin{itemize}
%
\item{\alltt null}: (\verb+var_len=0+) This means $R\equiv 0$. No
lienar reaction term is present. 
%
\item {\alltt global\_scalar} {\alltt [var_len==1]} (A scalar) 
The same source in all fields \(R_{\mu\nu} = {\bar R} \,
\delta_{\mu\nu}\). 
%
\item{\alltt scalar_per_field} {\alltt [var_len==ndof*ndof]}] 
A scalar for each field: 
\[  R_{\mu\nu} = {\bar R_\mu} \, \delta_{\mu\nu}\ \ \ 
                  \textrm{No sum over \(\mu\)} \]
%
\item{\alltt full} {\alltt [var_len==ndof*ndof]}] General case,
stored per row
\(\{\{R_{\mu\nu},\nu=1,\ndof\},\mu=1,\ndof\}\)
\end{itemize}

Which of the several possibilities is chosen depends on the size of
the vector entered and on the string value of the option
\verb+reactive_jacobians_type+, according to the rules described in
the \verb+advective_jacobians+ option documentation. 

  (found in file: \verb+../applications/advdif/ffadvfm2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\item\verb+ double[var_len]+ \verb+ reactive_jacobians+ {\rm(default=\verb| all zero|)}:
 
 FIXME:= TO BE DOCUMENTED LATER
  (found in file: \verb+../applications/advdif/ffadvfm2_old.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{reactive\_jacobians\_type@\verb+reactive_jacobians_type+}
\item\verb+string reactive_jacobians_type+ {\rm(default=\verb|string("undefined")|)}:

Set reactive jacobian to the desired type. 
 May be one of 
``\verb+null+'', 
``\verb+global_scalar+'', 
``\verb+scalar_per_field+''
or ``\verb+null+''
See documentation for the \verb+reactive_jacobians+ option. 
 (found in file: \verb+../applications/advdif/ffadvfm2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{real\_nodes@\verb+real_nodes+}
\item\verb+int real_nodes+ {\rm(default=\verb|0|)}:

Pass here the number of real nodes to be reported. 
 (found in file: \verb+../applications/ns/nsid.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{report\_assembly\_time@\verb+report_assembly_time+}
\item\verb+int report_assembly_time+ {\rm(default=\verb|0|)}:

Debug the process of building the matrix profile. 
 (found in file: \verb+../src/elemset.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{report\_consumed\_time@\verb+report_consumed_time+}
\item\verb+int report_consumed_time+ {\rm(default=\verb|0|)}:

Report consumed time for the elemset. Useful for building
the table of weights per processor. 
 (found in file: \verb+../src/elemset.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{report\_consumed\_time\_stat@\verb+report_consumed_time_stat+}
\item\verb+int report_consumed_time_stat+ {\rm(default=\verb|0|)}:

Print statistics about time spent in communication and residual evaluation
 (found in file: \verb+../src/elemset.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{report\_option\_access@\verb+report_option_access+}
\item\verb+int report_option_access+ {\rm(default=\verb|1|)}:

Print, after execution, a report of the times a given option
was accessed. Useful for detecting if an option was used or not.
 (found in file: \verb+../applications/advdif/advdif.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{report\_option\_access@\verb+report_option_access+}
\item\verb+int report_option_access+ {\rm(default=\verb|1|)}:

Print, after execution, a report of the times a given option
was accessed. Useful for detecting if an option was used or not.
 (found in file: \verb+../applications/advdif/advdif_bubbly.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{report\_option\_access@\verb+report_option_access+}
\item\verb+int report_option_access+ {\rm(default=\verb|1|)}:

Print, after execution, a report of the times a given option
was accessed. Useful for detecting if an option was used or not.
 (found in file: \verb+../applications/ns/ns.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{residual\_factor@\verb+residual_factor+}
\item\verb+double residual_factor+ {\rm(default=\verb|1.|)}:

Scale the residual term. 
 (found in file: \verb+../applications/ns/nsitetlesfm2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{restart@\verb+restart+}
\item\verb+int restart+ {\rm(default=\verb|0|)}:

Restart previous run
 (found in file: \verb+../test/spillway/alehook.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{restart@\verb+restart+}
\item\verb+int restart+ {\rm(default=\verb|0|)}:

Assume problem is periodic 
 (found in file: \verb+../test/spillway/alehook.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{reuse\_mat@\verb+reuse_mat+}
\item\verb+int reuse_mat+ {\rm(default=\verb|0|)}:

Use fractional step or TET algorithm
 (found in file: \verb+../applications/ns/ns.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{rho@\verb+rho+}
\item\verb+double rho+ {\rm(default=\verb|1.|)}:

Density
 (found in file: \verb+../applications/ns/bccnstherfm2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{rho@\verb+rho+}
\item\verb+double rho+ {\rm(default=\verb|1.|)}:

Density
 (found in file: \verb+../applications/ns/fracstep.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{rho@\verb+rho+}
\item\verb+double rho+ {\rm(default=\verb|1.|)}:

Density
 (found in file: \verb+../applications/ns/fstepfm2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{rho@\verb+rho+}
\item\verb+double rho+ {\rm(default=\verb|1.|)}:

Density
 (found in file: \verb+../applications/ns/nonlr.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{rho@\verb+rho+}
\item\verb+double rho+ {\rm(default=\verb|1.|)}:

Density
 (found in file: \verb+../applications/ns/nsikeps.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{rho@\verb+rho+}
\item\verb+double rho+ {\rm(default=\verb|1.|)}:

Density
 (found in file: \verb+../applications/ns/nsikepsrot.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{rho@\verb+rho+}
\item\verb+double rho+ {\rm(default=\verb|1.|)}:

Density
 (found in file: \verb+../applications/ns/nsilesther.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{rho@\verb+rho+}
\item\verb+double rho+ {\rm(default=\verb|1.|)}:

Density
 (found in file: \verb+../applications/ns/nsirot.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{rho@\verb+rho+}
\item\verb+double rho+ {\rm(default=\verb|1.|)}:

Density
 (found in file: \verb+../applications/ns/nsitetlesfm2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{rho@\verb+rho+}
\item\verb+double rho+ {\rm(default=\verb|1.|)}:

Gravity acceleration. 
 (found in file: \verb+../applications/ns/nssupr.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{rho@\verb+rho+}
\item\verb+double rho+ {\rm(default=\verb|1.|)}:

Density
 (found in file: \verb+../applications/ns/wall.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{rho@\verb+rho+}
\item\verb+double rho+ {\rm(default=\verb|1.|)}:

Density
 (found in file: \verb+../applications/ns/wallke.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{rho\_Cp@\verb+rho_Cp+}
\item\verb+double rho_Cp+ {\rm(default=\verb|1.|)}:

Specific heat
 (found in file: \verb+../applications/ns/qharm.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{rho\_thrsh@\verb+rho_thrsh+}
\item\verb+double rho_thrsh+ {\rm(default=\verb|0.|)}:

Threshold value for density. If density goes belows this value
 then a cutoff function is applied. This is a simple way to prevent
 crashing of the code due to taking square root of negative values.
 (found in file: \verb+../applications/advdif/gasflow.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{roughness@\verb+roughness+}
\item\verb+double roughness+ {\rm(default=\verb|1.|)}:

Roughness coefficient for the Manning formula (a.k.a. $n$)
 (found in file: \verb+../applications/advdif/stream.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{roughness@\verb+roughness+}
\item\verb+double roughness+ {\rm(default=\verb|0.|)}:

Roughness of the wall
 (found in file: \verb+../applications/advdif/wallswt.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{rtol@\verb+rtol+}
\item\verb+double rtol+ {\rm(default=\verb|1e-3|)}:

Relative tolerance when solving a consistent matrix
 (found in file: \verb+../applications/advdif/advdif.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{rtol@\verb+rtol+}
\item\verb+double rtol+ {\rm(default=\verb|1e-3|)}:

Relative tolerance when solving a consistent matrix
 (found in file: \verb+../applications/advdif/advdif_bubbly.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{rtol@\verb+rtol+}
\item\verb+double rtol+ {\rm(default=\verb|1e-3|)}:

Relative tolerance when solving a consistent matrix
 (found in file: \verb+../applications/advective/adv.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{rtol@\verb+rtol+}
\item\verb+double rtol+ {\rm(default=\verb|1e-3|)}:

Relative tolerance to solve the monolithic linear
system (Newton linear subiteration).
 (found in file: \verb+../src/iisdmat.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{save\_file@\verb+save_file+}
\item\verb+string save_file+ {\rm(default=\verb|outvector.out|)}:

Filename for saving the state vector.
 (found in file: \verb+../applications/advdif/advdif.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{save\_file@\verb+save_file+}
\item\verb+string save_file+ {\rm(default=\verb|outvector.out|)}:

Filename for saving the state vector.
 (found in file: \verb+../applications/advdif/advdif_bubbly.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{save\_file@\verb+save_file+}
\item\verb+string save_file+ {\rm(default=\verb|outvector.out|)}:

Filename for saving the state vector.
 (found in file: \verb+../applications/advective/adv.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{save\_file@\verb+save_file+}
\item\verb+string save_file+ {\rm(default=\verb|outvector.out|)}:

The name of the file to save the state vector. 
 (found in file: \verb+../applications/ns/ns.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{save\_file\_pattern@\verb+save_file_pattern+}
\item\verb+string save_file_pattern+ {\rm(default=\verb|outvector%d.out|)}:

The pattern to generate the file name to save in for
the rotary save mechanism.
 (found in file: \verb+../applications/advdif/advdif.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{save\_file\_pattern@\verb+save_file_pattern+}
\item\verb+string save_file_pattern+ {\rm(default=\verb|outvector%d.out|)}:

The pattern to generate the file name to save in for
the rotary save mechanism.
 (found in file: \verb+../applications/advdif/advdif_bubbly.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{save\_file\_pattern@\verb+save_file_pattern+}
\item\verb+string save_file_pattern+ {\rm(default=\verb|outvector%d.out|)}:

The pattern to generate the file name to save in for
the rotary save mechanism.
 (found in file: \verb+../applications/advective/adv.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{save\_file\_pattern@\verb+save_file_pattern+}
\item\verb+string save_file_pattern+ {\rm(default=\verb|outvector%d.out|)}:

The pattern to generate the file name to save in for
the rotary save mechanism.
 (found in file: \verb+../applications/ns/ns.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{save\_file\_some@\verb+save_file_some+}
\item\verb+string save_file_some+ {\rm(default=\verb|outvsome.out|)}:

Name of file where to save node values for the ``print some'' 
feature. 
 (found in file: \verb+../applications/advdif/advdif.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{save\_file\_some@\verb+save_file_some+}
\item\verb+string save_file_some+ {\rm(default=\verb|outvsome.out|)}:

Name of file where to save node values for the ``print some'' 
feature. 
 (found in file: \verb+../applications/advdif/advdif_bubbly.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{save\_file\_some@\verb+save_file_some+}
\item\verb+string save_file_some+ {\rm(default=\verb|outvsome.out|)}:

Name of file where to save node values for the ``print some'' 
feature. 
 (found in file: \verb+../applications/ns/ns.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{save\_file\_some\_append@\verb+save_file_some_append+}
\item\verb+int save_file_some_append+ {\rm(default=\verb|1|)}:

Access mode to the ``some'' file. If 0 rewind file. If 1 
 append to previous  results.
 (found in file: \verb+../applications/advdif/advdif.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{save\_file\_some\_append@\verb+save_file_some_append+}
\item\verb+int save_file_some_append+ {\rm(default=\verb|1|)}:

Access mode to the ``some'' file. If 0 rewind file. If 1 
 append to previous  results.
 (found in file: \verb+../applications/advdif/advdif_bubbly.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{save\_file\_some\_append@\verb+save_file_some_append+}
\item\verb+int save_file_some_append+ {\rm(default=\verb|1|)}:

Access mode to the ``some'' file. If 0 rewind file. If 1 
 append to previous  results.
 (found in file: \verb+../applications/ns/ns.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{shape@\verb+shape+}
\item\verb+string shape+ {\rm(default=\verb|string("undefined")|)}:

Choose channel section shape, may be {\tt circular},
 {\tt rectangular} or {\tt triangular}.
 (found in file: \verb+../applications/advdif/stream.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{shocap@\verb+shocap+}
\item\verb+double shocap+ {\rm(default=\verb|0.0|)}:

Add a shock capturing term
 (found in file: \verb+../applications/advdif/advdife.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{shocap@\verb+shocap+}
\item\verb+double shocap+ {\rm(default=\verb|0.0|)}:

Add a shock capturing term
 (found in file: \verb+../applications/advdif/pfcpp_temp.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{shock\_capturing@\verb+shock_capturing+}
\item\verb+int shock_capturing+ {\rm(default=\verb|0|)}:

Add shock-capturing term.
 (found in file: \verb+../applications/advdif/ffswfm1t.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{shock\_capturing@\verb+shock_capturing+}
\item\verb+int shock_capturing+ {\rm(default=\verb|0|)}:

Add shock-capturing term.
 (found in file: \verb+../applications/advdif/ffswfm2t.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{shock\_capturing@\verb+shock_capturing+}
\item\verb+int shock_capturing+ {\rm(default=\verb|0|)}:

Add shock-capturing term.
 (found in file: \verb+../applications/advective/ffeulerfm2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{shock\_capturing@\verb+shock_capturing+}
\item\verb+int shock_capturing+ {\rm(default=\verb|0|)}:

Add shock-capturing term.
 (found in file: \verb+../applications/advective/ffswfm2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{shock\_capturing@\verb+shock_capturing+}
\item\verb+int shock_capturing+ {\rm(default=\verb|0|)}:

Add shock-capturing term.
 (found in file: \verb+../applications/advective/ffswfm2t.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{shock\_capturing\_factor@\verb+shock_capturing_factor+}
\item\verb+double shock_capturing_factor+ {\rm(default=\verb|1|)}:

Add shock-capturing term.
 (found in file: \verb+../applications/ns/nsikeps.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{shock\_capturing\_factor@\verb+shock_capturing_factor+}
\item\verb+double shock_capturing_factor+ {\rm(default=\verb|1|)}:

Add shock-capturing term.
 (found in file: \verb+../applications/ns/nsikepsrot.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{shock\_capturing\_factor@\verb+shock_capturing_factor+}
\item\verb+double shock_capturing_factor+ {\rm(default=\verb|0|)}:

Add shock-capturing term.
 (found in file: \verb+../applications/ns/nsilesther.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{shock\_capturing\_factor@\verb+shock_capturing_factor+}
\item\verb+double shock_capturing_factor+ {\rm(default=\verb|1|)}:

Add shock-capturing term.
 (found in file: \verb+../applications/ns/nsirot.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{shock\_capturing\_factor@\verb+shock_capturing_factor+}
\item\verb+double shock_capturing_factor+ {\rm(default=\verb|0|)}:

Add shock-capturing term.
 (found in file: \verb+../applications/ns/nsitetlesfm2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{shock\_capturing\_threshold@\verb+shock_capturing_threshold+}
\item\verb+double shock_capturing_threshold+ {\rm(default=\verb|0.1|)}:

Add shock-capturing term if relative variation of variables
inside the element exceeds this.
 (found in file: \verb+../applications/advective/ffeulerfm2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{shock\_capturing\_threshold@\verb+shock_capturing_threshold+}
\item\verb+double shock_capturing_threshold+ {\rm(default=\verb|0.1|)}:

Add shock-capturing term if relative variation of variables
inside the element exceeds this.
 (found in file: \verb+../applications/advective/ffswfm2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{shock\_capturing\_threshold@\verb+shock_capturing_threshold+}
\item\verb+double shock_capturing_threshold+ {\rm(default=\verb|0.1|)}:

Add shock-capturing term if relative variation of variables
inside the element exceeds this.
 (found in file: \verb+../applications/advective/ffswfm2t.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{sigma@\verb+sigma+}
\item\verb+double sigma+ {\rm(default=\verb|half_width/0.83255|)}:

The standard deviation of the Gaussian
 (found in file: \verb+../src/tempfun2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{sigma\_e@\verb+sigma_e+}
\item\verb+double sigma_e+ {\rm(default=\verb|1.3|)}:

sigma_e
 (found in file: \verb+../applications/advdif/bubbly.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{sigma\_e@\verb+sigma_e+}
\item\verb+double sigma_e+ {\rm(default=\verb|1.3|)}:

Correcting factor for diffusion in the $\epsilon$ transport equation
 (found in file: \verb+../applications/advdif/ffswfm1t.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{sigma\_e@\verb+sigma_e+}
\item\verb+double sigma_e+ {\rm(default=\verb|1.3|)}:

Correcting factor for diffusion in the $\epsilon$ transport equation
 (found in file: \verb+../applications/advdif/ffswfm2t.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{sigma\_e@\verb+sigma_e+}
\item\verb+double sigma_e+ {\rm(default=\verb|1.3|)}:

sigma_e 
 (found in file: \verb+../applications/ns/nsikeps.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{sigma\_e@\verb+sigma_e+}
\item\verb+double sigma_e+ {\rm(default=\verb|1.3|)}:

sigma_e 
 (found in file: \verb+../applications/ns/nsikepsrot.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{sigma\_k@\verb+sigma_k+}
\item\verb+double sigma_k+ {\rm(default=\verb|1.|)}:

sigma_k
 (found in file: \verb+../applications/advdif/bubbly.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{sigma\_k@\verb+sigma_k+}
\item\verb+double sigma_k+ {\rm(default=\verb|1.|)}:

Correcting factor for diffusion in the $k$ transport equation
 (found in file: \verb+../applications/advdif/ffswfm1t.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{sigma\_k@\verb+sigma_k+}
\item\verb+double sigma_k+ {\rm(default=\verb|1.|)}:

Correcting factor for diffusion in the $k$ transport equation
 (found in file: \verb+../applications/advdif/ffswfm2t.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{sigma\_k@\verb+sigma_k+}
\item\verb+double sigma_k+ {\rm(default=\verb|1.|)}:

sigma_k 
 (found in file: \verb+../applications/ns/nsikeps.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{sigma\_k@\verb+sigma_k+}
\item\verb+double sigma_k+ {\rm(default=\verb|1.|)}:

sigma_k 
 (found in file: \verb+../applications/ns/nsikepsrot.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{solve\_system@\verb+solve_system+}
\item\verb+int solve_system+ {\rm(default=\verb|1|)}:

Solve system before \verb+print\_linear_system_and_stop+
 (found in file: \verb+../applications/advdif/advdif.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{solve\_system@\verb+solve_system+}
\item\verb+int solve_system+ {\rm(default=\verb|1|)}:

Solve system before \verb+print\_linear_system_and_stop+
 (found in file: \verb+../applications/advdif/advdif_bubbly.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{solve\_system@\verb+solve_system+}
\item\verb+int solve_system+ {\rm(default=\verb|1|)}:

Solve system before \verb+print\_linear_system_and_stop+
 (found in file: \verb+../applications/ns/ns.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{solver@\verb+solver+}
\item\verb+string solver+ {\rm(default=\verb|petsc|)}:

Type of solver. May be \verb+iisd+ or \verb+petsc+. 
 (found in file: \verb+../applications/advdif/advdif.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{solver@\verb+solver+}
\item\verb+string solver+ {\rm(default=\verb|petsc|)}:

Type of solver. May be \verb+iisd+ or \verb+petsc+. 
 (found in file: \verb+../applications/advdif/advdif_bubbly.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{solver@\verb+solver+}
\item\verb+string solver+ {\rm(default=\verb|petsc|)}:

Type of solver. May be \verb+iisd+ or \verb+petsc+. 
 (found in file: \verb+../applications/ns/ns.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{solver\_mom@\verb+solver_mom+}
\item\verb+string solver_mom+ {\rm(default=\verb|petsc|)}:

Type of solver for the projection and momentum steps
(fractional-step). May be \verb+iisd+ or \verb+petsc+.
 (found in file: \verb+../applications/ns/ns.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\item\verb+ double[var_len]+ \verb+ source term+ {\rm(default=\verb| all zero|)}:
 
Constant source term. 

The most general linear source term not can be put in the form
\[ G_\mu = R_{\mu\nu} U_\nu + S_\nu
\]
%
The second term represents a constant source term, whereas the first
term is linear in \(!U\) and sometimes is called a \emph{``reaction
term''}.  The constant part \(S_\mu\) is entered in the
\verb+source_term+ option whereas the \(R_{\mu\nu}\) coefficients are
entered in the \verb+reactive_jacobians+ option.

The more general source term has \verb+ndof+ components. But in many
cases it may be the same for all the fields or null.  The following
cases are considered. (See the general description for the
\verb+advective_jacobians+ entry).
%
\begin{itemize}
%
\item{\alltt null}: (\verb+var_len=0+) This means $S\equiv 0$. No
constant source term is present. 
%
\item {\alltt global_scalar} {\alltt [var_len==1]} (A scalar) 
The same source in all fields \(S_{\mu} = {\bar S}\). 
%
\item{\alltt full} {\alltt [var_len==ndof]}] General case. One source term
value per field. 
\end{itemize}

Which of the several possibilities is chosen depends on the size of
the vector entered and on the string value of the option
\verb+source_term_type+, according to the rules described in
the \verb+advective_jacobians+ option documentation. 
  (found in file: \verb+../applications/advdif/ffadvfm2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{source\_term\_type@\verb+source_term_type+}
\item\verb+string source_term_type+ {\rm(default=\verb|string("undefined")|)}:

Set source term to the desired type
 May be one of 
``\verb+null+'', 
``\verb+global_scalar+'', 
or ``\verb+null+''
See documentation for the ``\verb+source_term+'' option. 
 (found in file: \verb+../applications/advdif/ffadvfm2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{start\_comp\_time@\verb+start_comp_time+}
\item\verb+double start_comp_time+ {\rm(default=\verb|0.|)}:

Time to start computations
 (found in file: \verb+../applications/ns/ns.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{start\_time@\verb+start_time+}
\item\verb+double start_time+ {\rm(default=\verb|0.|)}:

Counts time from here.
 (found in file: \verb+../applications/advdif/advdif.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{start\_time@\verb+start_time+}
\item\verb+double start_time+ {\rm(default=\verb|0.|)}:

Counts time from here.
 (found in file: \verb+../applications/advdif/advdif_bubbly.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{start\_time@\verb+start_time+}
\item\verb+double start_time+ {\rm(default=\verb|0.|)}:

Counts time from here.
 (found in file: \verb+../applications/advective/adv.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\item\verb+ double[ndof]+ \verb+ state_ref+ {\rm(default=\verb| null vector|)}:
 Reference state value.  (found in file: \verb+../applications/ns/nsid.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\item\verb+ double[ndof]+ \verb+ state_ref+ {\rm(default=\verb| null vector|)}:
 Reference state value.  (found in file: \verb+../applications/ns/qharmm.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{stdout\_file@\verb+stdout_file+}
\item\verb+string stdout_file+ {\rm(default=\verb||)}:

If set, redirect output to this file.
 (found in file: \verb+../applications/ns/ns.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{steady@\verb+steady+}
\item\verb+int steady+ {\rm(default=\verb|0|)}:

Flag if steady solution or not (uses Dt=inf). If \verb+steady+
is set to 1, then the computations are as if $\Dt=\infty$. 
The value of \verb+Dt+ is used for printing etc... If \verb+Dt+
is not set and \verb+steady+ is set then \verb+Dt+ is set to one.
 (found in file: \verb+../applications/advdif/advdif.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{steady@\verb+steady+}
\item\verb+int steady+ {\rm(default=\verb|0|)}:

Flag if steady solution or not (uses Dt=inf). If \verb+steady+
is set to 1, then the computations are as if $\Dt=\infty$. 
The value of \verb+Dt+ is used for printing etc... If \verb+Dt+
is not set and \verb+steady+ is set then \verb+Dt+ is set to one.
 (found in file: \verb+../applications/ns/ns.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{steady@\verb+steady+}
\item\verb+int steady+ {\rm(default=\verb|0|)}:

Steady flag
 (found in file: \verb+../test/spillway/alehook.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{stop\_on\_neg\_val@\verb+stop_on_neg_val+}
\item\verb+int stop_on_neg_val+ {\rm(default=\verb|1|)}:

If this flag is activated the code stops when a negative 
 value for density or pressure is found. Setting either
 \verb+p_thrsh+ or \verb+rho_thrsh+ deactivates #stop_on_neg_val#. 
 (found in file: \verb+../applications/advdif/gasflow.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{t0@\verb+t0+}
\item\verb+double t0+ {\rm(default=\verb|0.|)}:

The time instant at which the peak of the Gaussian occurs 
 (found in file: \verb+../src/tempfun2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{t\_0@\verb+t_0+}
\item\verb+double t_0+ {\rm(default=\verb|0.|)}:

Shift in the time linear transformation.
$t = t_0 + t_scale * tau$. $t$ is time and $\tau$
is the pseudo-time entered in the second column of
the file. 
 (found in file: \verb+../src/tempfun2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{t\_scale@\verb+t_scale+}
\item\verb+double t_scale+ {\rm(default=\verb|1.|)}:

Temporal scale in the time linear transformation.
 (found in file: \verb+../src/tempfun2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{tau\_fac@\verb+tau_fac+}
\item\verb+double tau_fac+ {\rm(default=\verb|1.|)}:

sigma_e
 (found in file: \verb+../applications/advdif/bubbly.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{tau\_fac@\verb+tau_fac+}
\item\verb+double tau_fac+ {\rm(default=\verb|1.|)}:

Scale the SUPG upwind term. Set to 0 in order to
 not to include the upwind term. 
 (found in file: \verb+../applications/advdif/ffadvfm2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{tau\_fac@\verb+tau_fac+}
\item\verb+double tau_fac+ {\rm(default=\verb|1.|)}:

Scale the SUPG upwind term. 
 (found in file: \verb+../applications/advdif/ffadvfm2_old.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{tau\_fac@\verb+tau_fac+}
\item\verb+double tau_fac+ {\rm(default=\verb|1.|)}:

Scale the SUPG upwind term. Set to 0 in order to
 not to include the upwind term. 
 (found in file: \verb+../applications/advdif/ffburg.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{tau\_fac@\verb+tau_fac+}
\item\verb+double tau_fac+ {\rm(default=\verb|1.|)}:

Scale the SUPG upwind term. 
 (found in file: \verb+../applications/advdif/ffburg.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{tau\_fac@\verb+tau_fac+}
\item\verb+double tau_fac+ {\rm(default=\verb|1.|)}:

Scale the SUPG upwind term. 
 (found in file: \verb+../applications/advdif/ffburg_old.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{tau\_fac@\verb+tau_fac+}
\item\verb+double tau_fac+ {\rm(default=\verb|1.|)}:

Scale the SUPG upwind term. 
 (found in file: \verb+../applications/advdif/ffswfm1t.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{tau\_fac@\verb+tau_fac+}
\item\verb+double tau_fac+ {\rm(default=\verb|1.|)}:

Scale the SUPG upwind term. 
 (found in file: \verb+../applications/advdif/ffswfm2t.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{tau\_fac@\verb+tau_fac+}
\item\verb+double tau_fac+ {\rm(default=\verb|1.|)}:

Mask for stabilization term
 (found in file: \verb+../applications/advdif/gasflow.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{tau\_fac@\verb+tau_fac+}
\item\verb+double tau_fac+ {\rm(default=\verb|1.|)}:

Scale the SUPG upwind term. 
 (found in file: \verb+../applications/advective/ffeulerfm2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{tau\_fac@\verb+tau_fac+}
\item\verb+double tau_fac+ {\rm(default=\verb|1.|)}:

Scale the SUPG upwind term. 
 (found in file: \verb+../applications/advective/ffswfm2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{tau\_fac@\verb+tau_fac+}
\item\verb+double tau_fac+ {\rm(default=\verb|1.|)}:

Scale the SUPG upwind term. 
 (found in file: \verb+../applications/advective/ffswfm2t.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{tau\_fac@\verb+tau_fac+}
\item\verb+double tau_fac+ {\rm(default=\verb|1.|)}:

Scale the SUPG upwind term. 
 (found in file: \verb+../applications/ns/nsikeps.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{tau\_fac@\verb+tau_fac+}
\item\verb+double tau_fac+ {\rm(default=\verb|1.|)}:

Scale the SUPG upwind term. 
 (found in file: \verb+../applications/ns/nsikepsrot.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{tau\_fac@\verb+tau_fac+}
\item\verb+double tau_fac+ {\rm(default=\verb|1.|)}:

Scale the SUPG upwind term.
 (found in file: \verb+../applications/ns/nsilesther.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{tau\_fac@\verb+tau_fac+}
\item\verb+double tau_fac+ {\rm(default=\verb|1.|)}:

Scale the SUPG upwind term.
 (found in file: \verb+../applications/ns/nsirot.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{tau\_fac@\verb+tau_fac+}
\item\verb+double tau_fac+ {\rm(default=\verb|1.|)}:

Scale the SUPG upwind term. 
 (found in file: \verb+../applications/ns/nsitetlesfm2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{temporal\_stability\_factor@\verb+temporal_stability_factor+}
\item\verb+double temporal_stability_factor+ {\rm(default=\verb|1.|)}:

Adjust the stability parameters, taking into account
the time step. If the \verb+steady+ option is in effect,
(which is equivalent to $\Dt=\infty$) then
\verb+temporal_stability_factor+ is set to 0.
 (found in file: \verb+../applications/advdif/bubbly.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{temporal\_stability\_factor@\verb+temporal_stability_factor+}
\item\verb+double temporal_stability_factor+ {\rm(default=\verb|1.|)}:

Adjust the stability parameters, taking into account
the time step. If the \verb+steady+ option is in effect,
(which is equivalent to $\Dt=\infty$) then
#temporal_stability_factor# is set to 0.
 (found in file: \verb+../applications/advdif/gasflow.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{temporal\_stability\_factor@\verb+temporal_stability_factor+}
\item\verb+double temporal_stability_factor+ {\rm(default=\verb|0.|)}:

Adjust the stability parameters, taking into account
the time step. 
 (found in file: \verb+../applications/ns/nsikeps.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{temporal\_stability\_factor@\verb+temporal_stability_factor+}
\item\verb+double temporal_stability_factor+ {\rm(default=\verb|0.|)}:

Adjust the stability parameters, taking into account
the time step. 
 (found in file: \verb+../applications/ns/nsikepsrot.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{temporal\_stability\_factor@\verb+temporal_stability_factor+}
\item\verb+double temporal_stability_factor+ {\rm(default=\verb|0.|)}:

Adjust the stability parameters, taking into account
the time step.
 (found in file: \verb+../applications/ns/nsilesther.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{temporal\_stability\_factor@\verb+temporal_stability_factor+}
\item\verb+double temporal_stability_factor+ {\rm(default=\verb|0.|)}:

Adjust the stability parameters, taking into account
the time step.
 (found in file: \verb+../applications/ns/nsirot.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{temporal\_stability\_factor@\verb+temporal_stability_factor+}
\item\verb+double temporal_stability_factor+ {\rm(default=\verb|0.|)}:

Adjust the stability parameters, taking into account
the time step. If the \verb+steady+ option is in effect,
(which is equivalent to $\Dt=\infty$) then
\verb+temporal_stability_factor+ is set to 0.
 (found in file: \verb+../applications/ns/nsitetlesfm2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{time\_step\_stop@\verb+time_step_stop+}
\item\verb+int time_step_stop+ {\rm(default=\verb|1|)}:

If \verb+print_linear_system_and_stop+ is active,
then print system in this time step
 (found in file: \verb+../applications/advdif/advdif.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{time\_step\_stop@\verb+time_step_stop+}
\item\verb+int time_step_stop+ {\rm(default=\verb|1|)}:

If \verb+print_linear_system_and_stop+ is active,
then print system in this time step
 (found in file: \verb+../applications/advdif/advdif_bubbly.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{tol\_linear@\verb+tol_linear+}
\item\verb+double tol_linear+ {\rm(default=\verb|1e-3|)}:

Tolerance when solving the sublinear problem
at each iteration.
 (found in file: \verb+../applications/advdif/advdif.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{tol\_linear@\verb+tol_linear+}
\item\verb+double tol_linear+ {\rm(default=\verb|1e-3|)}:

Tolerance when solving the sublinear problem
at each iteration.
 (found in file: \verb+../applications/advdif/advdif_bubbly.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{tol\_mass@\verb+tol_mass+}
\item\verb+double tol_mass+ {\rm(default=\verb|1e-3|)}:

Tolerance when solving with the mass matrix. 
 (found in file: \verb+../applications/advdif/advdif.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{tol\_mass@\verb+tol_mass+}
\item\verb+double tol_mass+ {\rm(default=\verb|1e-3|)}:

Tolerance when solving with the mass matrix. 
 (found in file: \verb+../applications/advdif/advdif_bubbly.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{tol\_mass@\verb+tol_mass+}
\item\verb+double tol_mass+ {\rm(default=\verb|1e-3|)}:

Tolerance when solving with the mass matrix. 
 (found in file: \verb+../applications/advective/adv.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{tol\_newton@\verb+tol_newton+}
\item\verb+double tol_newton+ {\rm(default=\verb|1e-3|)}:

Tolerance when solving the non-linear problem
for the implicit case.
 (found in file: \verb+../applications/advdif/advdif.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{tol\_newton@\verb+tol_newton+}
\item\verb+double tol_newton+ {\rm(default=\verb|1e-3|)}:

Tolerance when solving the non-linear problem
for the implicit case.
 (found in file: \verb+../applications/advdif/advdif_bubbly.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{tol\_newton@\verb+tol_newton+}
\item\verb+double tol_newton+ {\rm(default=\verb|1e-8|)}:

Tolerance to solve the non-linear system (global Newton).
 (found in file: \verb+../applications/ns/ns.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{tol\_steady@\verb+tol_steady+}
\item\verb+double tol_steady+ {\rm(default=\verb|0.|)}:

Tolerance when solving for a steady state
 (found in file: \verb+../applications/advdif/advdif.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{tol\_steady@\verb+tol_steady+}
\item\verb+double tol_steady+ {\rm(default=\verb|0.|)}:

Tolerance when solving for a steady state
 (found in file: \verb+../applications/advdif/advdif_bubbly.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{turb\_prod\_coef@\verb+turb_prod_coef+}
\item\verb+double turb_prod_coef+ {\rm(default=\verb|1.|)}:

Mask to the production terms in the k and epsilon
equations. This terms are then scaled by
\verb+turbulence_coef*turb_prod_coef+. 
 (found in file: \verb+../applications/ns/nsikeps.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{turb\_prod\_coef@\verb+turb_prod_coef+}
\item\verb+double turb_prod_coef+ {\rm(default=\verb|1.|)}:

Mask to the production terms in the k and epsilon
equations. This terms are then scaled by
\verb+turbulence_coef*turb_prod_coef+. 
 (found in file: \verb+../applications/ns/nsikepsrot.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{turbulence\_coef@\verb+turbulence_coef+}
\item\verb+double turbulence_coef+ {\rm(default=\verb|1.|)}:

Do not impose the relation between k,epsilon at the wall. 
 (found in file: \verb+../applications/ns/nonlr.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{turbulence\_coef@\verb+turbulence_coef+}
\item\verb+double turbulence_coef+ {\rm(default=\verb|1.|)}:

Do not add turbulent viscosity for the momentum eq. (for
  debugging). 
 (found in file: \verb+../applications/ns/nsikeps.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{turbulence\_coef@\verb+turbulence_coef+}
\item\verb+double turbulence_coef+ {\rm(default=\verb|1.|)}:

Do not add turbulent viscosity for the momentum eq. (for
  debugging). 
 (found in file: \verb+../applications/ns/nsikepsrot.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{turbulence\_coef@\verb+turbulence_coef+}
\item\verb+double turbulence_coef+ {\rm(default=\verb|1.|)}:

Mask for using laminar relation (\verb+turbulence_coef=0+). 
 (found in file: \verb+../applications/ns/wallke.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\item\verb+ double[ndim]+ \verb+ u0+ {\rm(default=\verb| [1,0]|)}:
 Vector defining direction for flux. 
 (found in file: \verb+../applications/advdif/ffburg.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\item\verb+ double[ndim]+ \verb+ u0+ {\rm(default=\verb| unit vector along $x$ axis|)}:
 Vector defining direction for flux. 
 (found in file: \verb+../applications/advdif/ffburg_old.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{update\_jacobian\_iters@\verb+update_jacobian_iters+}
\item\verb+int update_jacobian_iters+ {\rm(default=\verb|1|)}:

Update jacobian only until n-th Newton subiteration. 
Don't update if null. 
 (found in file: \verb+../applications/advdif/advdif.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{update\_jacobian\_iters@\verb+update_jacobian_iters+}
\item\verb+int update_jacobian_iters+ {\rm(default=\verb|1|)}:

Update jacobian only until n-th Newton subiteration. 
Don't update if null. 
 (found in file: \verb+../applications/ns/ns.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{update\_jacobian\_start\_iters@\verb+update_jacobian_start_iters+}
\item\verb+int update_jacobian_start_iters+ {\rm(default=\verb|INF|)}:

Update jacobian each $n$-th Newton iteration
 (found in file: \verb+../applications/advdif/advdif.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{update\_jacobian\_start\_iters@\verb+update_jacobian_start_iters+}
\item\verb+int update_jacobian_start_iters+ {\rm(default=\verb|INF|)}:

Update jacobian each $n$-th Newton iteration
 (found in file: \verb+../applications/ns/ns.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{update\_jacobian\_start\_steps@\verb+update_jacobian_start_steps+}
\item\verb+int update_jacobian_start_steps+ {\rm(default=\verb|INF|)}:

Update jacobian each $n$-th time step. 
 (found in file: \verb+../applications/advdif/advdif.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{update\_jacobian\_start\_steps@\verb+update_jacobian_start_steps+}
\item\verb+int update_jacobian_start_steps+ {\rm(default=\verb|INF|)}:

Update jacobian each $n$-th time step. 
 (found in file: \verb+../applications/ns/ns.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{update\_jacobian\_steps@\verb+update_jacobian_steps+}
\item\verb+int update_jacobian_steps+ {\rm(default=\verb|0|)}:

Update jacobian each $n$-th time step. 
 (found in file: \verb+../applications/advdif/advdif.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{update\_jacobian\_steps@\verb+update_jacobian_steps+}
\item\verb+int update_jacobian_steps+ {\rm(default=\verb|0|)}:

Update jacobian each $n$-th time step. 
 (found in file: \verb+../applications/ns/ns.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{use\_compact\_profile@\verb+use_compact_profile+}
\item\verb+int use_compact_profile+ {\rm(default=\verb|LINK_GRAPH|)}:

Choice representation of the profile graph. Possible values are:
0) Adjacency graph classes
based on STL map+set, demands too much memory, CPU time OK.
1) Based on dynamic vector of pair of indices with resorting,
demands too much CPU time, RAM is OK
2) For each vertex wee keep a linked list of cells containing the
adjacent nodes. Each insertion is $O(m^2)$ where $m$ is the average
number of adjacent vertices. This seems to be optimal for
FEM connectivities.
 (found in file: \verb+../src/iisdmat.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{use\_exterior\_normal@\verb+use_exterior_normal+}
\item\verb+int use_exterior_normal+ {\rm(default=\verb|1|)}:

Use exterior or interior normal
 (found in file: \verb+../applications/ns/embgath.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{use\_exterior\_normal@\verb+use_exterior_normal+}
\item\verb+int use_exterior_normal+ {\rm(default=\verb|1|)}:

Use exterior or interior normal
 (found in file: \verb+../src/surf2vol.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{use\_iisd@\verb+use_iisd+}
\item\verb+int use_iisd+ {\rm(default=\verb|0|)}:

Use IISD (Interface Iterative Subdomain Direct) or not.
 (found in file: \verb+../applications/advdif/advdif.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{use\_iisd@\verb+use_iisd+}
\item\verb+int use_iisd+ {\rm(default=\verb|0|)}:

Use IISD (Interface Iterative Subdomain Direct) or not.
 (found in file: \verb+../applications/advdif/advdif_bubbly.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{use\_iisd@\verb+use_iisd+}
\item\verb+int use_iisd+ {\rm(default=\verb|0|)}:

Use IISD (Interface Iterative Subdomain Direct) or not.
 (found in file: \verb+../applications/ns/ns.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{use\_interface\_full\_preco@\verb+use_interface_full_preco+}
\item\verb+int use_interface_full_preco+ {\rm(default=\verb|0|)}:

Chooses the preconditioning operator. 
 (found in file: \verb+../src/iisdcr.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{use\_interface\_full\_preco\_nlay@\verb+use_interface_full_preco_nlay+}
\item\verb+int use_interface_full_preco_nlay+ {\rm(default=\verb|1|)}:

Number of layers in the preconditioning band (should
 be \verb+nlay>=1+.) 
 (found in file: \verb+../src/iisdcr.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{use\_log\_vars@\verb+use_log_vars+}
\item\verb+int use_log_vars+ {\rm(default=\verb|0|)}:

Use log-vars for $k$ and $\epsilon$
 (found in file: \verb+../applications/advdif/advdife.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{use\_log\_vars@\verb+use_log_vars+}
\item\verb+int use_log_vars+ {\rm(default=\verb|0|)}:

Use log-vars for $k$ and $\epsilon$
 (found in file: \verb+../applications/advdif/advdifeo.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{use\_log\_vars@\verb+use_log_vars+}
\item\verb+int use_log_vars+ {\rm(default=\verb|0|)}:

Use log-vars for $k$ and $\epsilon$
 (found in file: \verb+../applications/advdif/pfcpp_temp.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{vel\_min@\verb+vel_min+}
\item\verb+double vel_min+ {\rm(default=\verb|1e-6|)}:

Threshold value for velocity while computing turbulence model.
 (found in file: \verb+../applications/advdif/ffswfm2t.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{viscosity@\verb+viscosity+}
\item\verb+double viscosity+ {\rm(default=\verb|1|)}:

Viscosity
 (found in file: \verb+../applications/advdif/wallswt.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{viscosity@\verb+viscosity+}
\item\verb+double viscosity+ {\rm(default=\verb|0.|)}:

Viscosity of the fluid
 (found in file: \verb+../applications/ns/embgath.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{viscosity@\verb+viscosity+}
\item\verb+double viscosity+ {\rm(default=\verb|0.|)}:

Dynamic viscosity
 (found in file: \verb+../applications/ns/invcoupl.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{viscosity@\verb+viscosity+}
\item\verb+double viscosity+ {\rm(default=\verb|1.|)}:

viscosity of the fluid
 (found in file: \verb+../applications/ns/nonlr.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{volume\_elemset@\verb+volume_elemset+}
\item\verb+string volume_elemset+ {\rm(default=\verb||)}:

The name of the volume elemset where to find
the volume element.
 (found in file: \verb+../applications/ns/embgath.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{volume\_elemset@\verb+volume_elemset+}
\item\verb+string volume_elemset+ {\rm(default=\verb|<none>|)}:

The elemset that is on the fluid side. 
 (found in file: \verb+../applications/ns/nullvort.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{volume\_gather\_pos@\verb+volume_gather_pos+}
\item\verb+int volume_gather_pos+ {\rm(default=\verb|-1|)}:

Position of the computed volume in the gather vector
 (found in file: \verb+../test/spillway/alehook.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{volume\_ref@\verb+volume_ref+}
\item\verb+double volume_ref+ {\rm(default=\verb|0.|)}:

Reference volume. Fluxes are injected to the bottom in order
 to reach this value/
 (found in file: \verb+../test/spillway/alehook.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{volume\_relax\_coef@\verb+volume_relax_coef+}
\item\verb+double volume_relax_coef+ {\rm(default=\verb|1.|)}:

Coefficient for relax in the volume correction
 (found in file: \verb+../test/spillway/alehook.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{von\_Karman\_cnst@\verb+von_Karman_cnst+}
\item\verb+double von_Karman_cnst+ {\rm(default=\verb|1.|)}:

The von Karman constant
 (found in file: \verb+../applications/advdif/wallswt.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{von\_Karman\_cnst@\verb+von_Karman_cnst+}
\item\verb+double von_Karman_cnst+ {\rm(default=\verb|0.4|)}:

von Karman constant (law of the wall - turbulence model)
 (found in file: \verb+../applications/ns/nonlr.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{weak\_form@\verb+weak_form+}
\item\verb+int weak_form+ {\rm(default=\verb|1|)}:

Use the weak form for the Galerkin part of the advective term.
 (found in file: \verb+../applications/advdif/advdife.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{weak\_form@\verb+weak_form+}
\item\verb+int weak_form+ {\rm(default=\verb|1|)}:

Use the weak form for the Galerkin part of the advective term. 
 (found in file: \verb+../applications/advdif/advdifeo.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{weak\_form@\verb+weak_form+}
\item\verb+int weak_form+ {\rm(default=\verb|1|)}:

Use the weak form for the Galerkin part of the advective term.
 (found in file: \verb+../applications/advdif/pfcpp_temp.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{weak\_form@\verb+weak_form+}
\item\verb+int weak_form+ {\rm(default=\verb|1|)}:

Use the weak form for the Galerkin part of the advective term. 
 (found in file: \verb+../applications/advective/advecfm2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{weak\_form@\verb+weak_form+}
\item\verb+int weak_form+ {\rm(default=\verb|0|)}:

Use the weak form for the Galerkin part of the advective term. 
 (found in file: \verb+../applications/advective/advective.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{weak\_form@\verb+weak_form+}
\item\verb+int weak_form+ {\rm(default=\verb|1|)}:

Use a weak form for the gradient of pressure term. 
 (found in file: \verb+../applications/ns/bccnsfm2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{weak\_form@\verb+weak_form+}
\item\verb+int weak_form+ {\rm(default=\verb|1|)}:

Use a weak form for the gradient of pressure term and thermal equation.
 (found in file: \verb+../applications/ns/bccnstherfm2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{weak\_form@\verb+weak_form+}
\item\verb+int weak_form+ {\rm(default=\verb|1|)}:

Use a weak form for the gradient of pressure term.
 (found in file: \verb+../applications/ns/nsikeps.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{weak\_form@\verb+weak_form+}
\item\verb+int weak_form+ {\rm(default=\verb|1|)}:

Use a weak form for the gradient of pressure term.
 (found in file: \verb+../applications/ns/nsikepsrot.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{weak\_form@\verb+weak_form+}
\item\verb+int weak_form+ {\rm(default=\verb|1|)}:

Use a weak form for the gradient of pressure term.
 (found in file: \verb+../applications/ns/nsilesther.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{weak\_form@\verb+weak_form+}
\item\verb+int weak_form+ {\rm(default=\verb|1|)}:

Use a weak form for the gradient of pressure term.
 (found in file: \verb+../applications/ns/nsirot.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{weak\_form@\verb+weak_form+}
\item\verb+int weak_form+ {\rm(default=\verb|1|)}:

Use a weak form for the gradient of pressure term.
 (found in file: \verb+../applications/ns/nsitetlesfm2.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{wet\_aquifer\_width\_min@\verb+wet_aquifer_width_min+}
\item\verb+double wet_aquifer_width_min+ {\rm(default=\verb|0.|)}:

Threshold for wet aquifer width (#phi-eta#)
 (found in file: \verb+../applications/advdif/aquifer.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{wet\_aquifer\_width\_min@\verb+wet_aquifer_width_min+}
\item\verb+double wet_aquifer_width_min+ {\rm(default=\verb|0.|)}:

Threshold for wet aquifer width (#phi-eta#)
 (found in file: \verb+../applications/advdif/aquifer.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{y\_wall@\verb+y_wall+}
\item\verb+double y_wall+ {\rm(default=\verb|0.|)}:

The $y$ (normal) coordinate of the computational boundary. 
Only for laminar computations.
 (found in file: \verb+../applications/ns/nonlr.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{y\_wall@\verb+y_wall+}
\item\verb+double y_wall+ {\rm(default=\verb|0.|)}:

The $y$ (normal) coordinate of the computational boundary. 
Only for laminar computations.
 (found in file: \verb+../applications/ns/wallke.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{y\_wall\_plus@\verb+y_wall_plus+}
\item\verb+double y_wall_plus+ {\rm(default=\verb|8.|)}:

The non-dmensional distance to the wall
 (found in file: \verb+../applications/advdif/wallswt.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{y\_wall\_plus@\verb+y_wall_plus+}
\item\verb+double y_wall_plus+ {\rm(default=\verb|30.|)}:

The $y^+$ coordinate of the computational boundary
 (found in file: \verb+../applications/ns/nonlr.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{y\_wall\_plus@\verb+y_wall_plus+}
\item\verb+double y_wall_plus+ {\rm(default=\verb|25.|)}:

The $y^+$ coordinate of the computational boundary
 (found in file: \verb+../applications/ns/wall.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
\index{y\_wall\_plus@\verb+y_wall_plus+}
\item\verb+double y_wall_plus+ {\rm(default=\verb|30.|)}:

The $y^+$ coordinate of the computational boundary
 (found in file: \verb+../applications/ns/wallke.cpp+)
%----<>----<>----<>----<>----<>----<>----<>----<>----<>----<>
%-----<>-----<>-----<>-----<>-----<>-----<>-----<>-----<>-----<>-----<>
% DON'T EDIT MANUALLY THIS FILE !!!!!!
% This files automatically generated by odoc.pl from 
% source file ""
%-----<>-----<>-----<>-----<>-----<>-----<>-----<>-----<>-----<>-----<>
