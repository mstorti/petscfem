%__INSERT_LICENSE__
%<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*> 
%section rotary_save
\label{sec:rotary_save}
Sometimes it is interesting to save the state vector with a certain
frequency in a ``append'' manner, i.e. appending the state vector at
the end of the file. However, this posses the danger of storing too
much amount of data if the user performs a very long run. The ``rotary
save'' mechanism allows writing only a certain amount of the recent
states. The mechanism basically saves the state vector each
\verb+nsaverot+ steps appending to the a file. The name of the file is
contructed from a pattern set by the user via the
\verb+save_file_pattern+ entry, by replacing \verb+%d+ 
by \verb+0+ ``\`a la'' \verb+printf()+. For instance, if
\verb+save_file_pattern+ i set to \verb+file%d.out+ 
then the state vectors are appended to \verb+file0.out+.  When the
number of written states reach the \verb+nrec+ count, the file is
reset to 0, and the saving continues from the start of the
file. However, if \verb+nfile+ is greater than one, then the state
vector are continued to be stored in file \verb+file1.out+ and so
on. When the number of files \verb+nfile+ is reached, the saving
continues in file '0'.

More precisely, the saving mechanism is described by the following
pseudo-code:

% %\begin{latexonly}
% % algorithmic environment is not correctly processed by Latex2HTML
% \begin{algorithmic}
% \STATE read state vector from \verb+initial_state+ file into $x^0$, $n\gets 0$.
% \FOR{$i$=0 to {\tt nstep}}
%   \STATE advance $x^n$ to $x^{n+1}$.
%   \IF{$n$ \% {\tt nsaverot} == 0}
%     \STATE $j \gets n$/{\tt nsaverot}
%     \STATE $k \gets j$ \% {\tt nrec}
%     \STATE $l \gets j$/{\tt nrec}
%     \IF{$k=0$}\STATE rewind file $l$ \ENDIF
%     \STATE append state vector to file $l$
%   \ENDIF
% \ENDFOR
% \end{algorithmic}
% %\end{latexonly}
%%%<>%%%<>%%%<>%%%<>%%%<>%%%<>%%%<>%%%<>%%%<>%%%<>%%%<>%%%<>%%%<> 
% algorithmic environment is not correctly processed by Latex2HTML
% \begin{htmlonly}
\begin{verbatim}
Read state vector from `initial_state' file into x^0, n=0;
for (i=0; i<nstep; i++) {
   advance x^n to x^{n+1};
   if (n % nsaverot == 0) {
           j <- n/nsaverot;
           k <- j % nrec;
           l <- j / nrec;
           if (k==0) { rewind file l; }
           append state vector to file l;
   }
}
\end{verbatim}
% \end{htmlonly}
%end_section

%<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*> 
%section print_some
\label{sec:print_some}
The ``print some'' mechanism allows the user to store the variables of
some set of nodes with some frequency. The nodes are entered in a
separate file whose name is given by a \verb+print_some_file+ entry in
the general options, one node per line. The entry \verb+nsome+
indicates the frequency (in steps) at which the data is saved and
\verb+save_file_some+ the name of the file to save in. 
%end_section

%<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*> 
%section newton_relaxation_factor
Relaxation parameter for Newton iteration. Several
values may be entered in the form
%
\begin{verbatim} 
newton_relaxation_factor w1 n1 w2 n2 .... wn
\end{verbatim}
%
that means: Take relaxation factor \verb+w1+
for the first \verb+n1+ steps, \verb+w2+ for the following \verb+n2+ steps
and so on until \verb+w_{n-1}+. \verb+wn+ is taken for all subsequent 
steps. Normally one takes a conservative (said 0.5) relaxation
factor for the first steps and then let full Newton (i.e. \verb+w=1+)
for the rest. For instance, the line  
%
\begin{verbatim} 
newton_relaxation_factor 0.5 3 1.
\end{verbatim}
%
means: take $w=0.5$ for the first 3 steps, and then use $w=1$. 
%end_section

%<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*>---<*> 
%section print_some
\label{sec:free_surface}

\def\Cnst#1{C_{\mathrm{#1}}}
The equation of the free surface is 
%
\begin{equation} 
\dtots\eta t = w
\end{equation}
%
where $\eta$ 
elevation, and $w$ is the velocity component normal to the free
surface. We modify this as follows 
%
\begin{equation} 
C_{\mathrm{eq}}\,\dtotd\eta t 
   + C_{\mathrm{lf}} \eta + C_{\mathrm{damp}} \, \Delta \eta = w
\end{equation}
%
Where
$damp=free_surface_damp# smoothes the free surface.
#ceq=fs_eq_factor# (see #fs_eq_factor# doc) is a factor that makes the
free surface more rigid.  #clf=free_surface_set_level_factor# (see doc
for that option) tries to keep the free surface level constant.

%end_section
